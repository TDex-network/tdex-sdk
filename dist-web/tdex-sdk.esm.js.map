{"version":3,"file":"tdex-sdk.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/core.ts","../src/utils.ts","../src/swap.ts","../src/grpcClient.web.ts","../src/transaction.ts","../src/trade-core.ts","../src/trade.web.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export interface CoreInterface {\n  verbose?: Boolean;\n  chain?: string;\n  providerUrl?: string;\n  explorerUrl?: string;\n}\n\nexport default class Core {\n  public verbose?: Boolean = false;\n  public chain?: string = 'regtest';\n  public providerUrl?: string;\n  public explorerUrl?: string;\n\n  constructor(data?: SafePick<Core>) {\n    Object.assign(this, data);\n  }\n}\n\ntype NonMethodKeys<T> = ({\n  [P in keyof T]: T[P] extends Function ? never : P;\n} & { [x: string]: never })[keyof T];\ntype SafePick<T> = Pick<T, NonMethodKeys<T>>;\n","import { Psbt, Transaction } from 'liquidjs-lib';\n\n/**\n * Generates a random id of a fixed length.\n * @param length size of the string id.\n */\nexport function makeid(length: number): string {\n  let result = '';\n  const characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport function decodePsbt(\n  psetBase64: string\n): { psbt: Psbt; transaction: Transaction } {\n  let psbt: Psbt;\n  try {\n    psbt = Psbt.fromBase64(psetBase64);\n  } catch (ignore) {\n    throw new Error('Invalid psbt');\n  }\n\n  const bufferTx = psbt.data.globalMap.unsignedTx.toBuffer();\n  const transaction = Transaction.fromBuffer(bufferTx);\n  return {\n    psbt,\n    transaction,\n  };\n}\n\nexport function getClearTextTorProxyUrl(\n  torProxyEndpoint: string,\n  url: URL\n): string {\n  // get just_onion_host_without_dot_onion\n  const splitted = url.hostname.split('.');\n  splitted.pop();\n  const onionPubKey = splitted.join('.');\n\n  return `${torProxyEndpoint}/${onionPubKey}`;\n}\n","import Core from './core';\nimport { confidential, TxOutput, Transaction } from 'liquidjs-lib';\nimport * as proto from 'tdex-protobuf/generated/js/swap_pb';\nimport * as jspb from 'google-protobuf';\nimport { isConfidentialOutput, unblindOutput } from 'ldk';\nimport { makeid, decodePsbt } from './utils';\n\n// type for BlindingKeys\ntype BlindKeysMap = Record<string, Buffer>;\n\n// define the Swap.request arguments.\ninterface requestOpts {\n  assetToBeSent: string;\n  amountToBeSent: number;\n  assetToReceive: string;\n  amountToReceive: number;\n  psetBase64: string;\n  inputBlindingKeys?: BlindKeysMap;\n  outputBlindingKeys?: BlindKeysMap;\n}\n\n// define the Swap.accept arguments.\ninterface acceptOpts {\n  message: Uint8Array;\n  psetBase64: string;\n  inputBlindingKeys?: BlindKeysMap;\n  outputBlindingKeys?: BlindKeysMap;\n}\n\n/**\n * The Swap class implements the Swap TDEX protocol i.e swap.request, swap.accept and swap.complete.\n * @see https://github.com/TDex-network/tdex-specs/blob/master/03-swap-protocol.md\n */\nexport class Swap extends Core {\n  static parse = parse;\n\n  /**\n   * Create and serialize a SwapRequest Message.\n   * @param args the args of swap.request see requestOpts.\n   */\n  async request({\n    amountToBeSent,\n    assetToBeSent,\n    amountToReceive,\n    assetToReceive,\n    psetBase64,\n    inputBlindingKeys,\n    outputBlindingKeys,\n  }: requestOpts): Promise<Uint8Array> {\n    // Check amounts\n    const msg = new proto.SwapRequest();\n    msg.setId(makeid(8));\n    msg.setAmountP(amountToBeSent);\n    msg.setAssetP(assetToBeSent);\n    msg.setAmountR(amountToReceive);\n    msg.setAssetR(assetToReceive);\n    msg.setTransaction(psetBase64);\n\n    if (inputBlindingKeys) {\n      // set the input blinding keys\n      Object.entries(inputBlindingKeys).forEach(([key, value]) => {\n        msg.getInputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    if (outputBlindingKeys) {\n      // set the output blinding keys\n      Object.entries(outputBlindingKeys).forEach(([key, value]) => {\n        msg.getOutputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    // check the message content and transaction.\n    await compareMessagesAndTransaction(msg);\n\n    if (this.verbose) console.log(msg.toObject());\n\n    return msg.serializeBinary();\n  }\n\n  /**\n   * Create and serialize an accept message.\n   * @param args the Swap.accept args, see AcceptOpts.\n   */\n  async accept({\n    message,\n    psetBase64,\n    inputBlindingKeys,\n    outputBlindingKeys,\n  }: acceptOpts): Promise<Uint8Array> {\n    // deserialize message parameter to get the SwapRequest message.\n    const msgRequest = proto.SwapRequest.deserializeBinary(message);\n    // Build Swap Accept message\n    const msgAccept = new proto.SwapAccept();\n    msgAccept.setId(makeid(8));\n    msgAccept.setRequestId(msgRequest.getId());\n    msgAccept.setTransaction(psetBase64);\n\n    if (inputBlindingKeys) {\n      // set the input blinding keys\n      Object.entries(inputBlindingKeys).forEach(([key, value]) => {\n        msgAccept.getInputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    if (outputBlindingKeys) {\n      // set the output blinding keys\n      Object.entries(outputBlindingKeys).forEach(([key, value]) => {\n        msgAccept.getOutputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    // compare messages and transaction data\n    await compareMessagesAndTransaction(msgRequest, msgAccept);\n\n    if (this.verbose) console.log(msgAccept.toObject());\n\n    // serialize the SwapAccept message.\n    return msgAccept.serializeBinary();\n  }\n\n  /**\n   * create and serialize a SwapComplete message.\n   * @param args contains the SwapAccept message + the base64 encoded transaction.\n   */\n  complete({\n    message,\n    psetBase64,\n  }: {\n    message: Uint8Array;\n    psetBase64: string;\n  }): Uint8Array {\n    //First validate signatures\n    const { psbt } = decodePsbt(psetBase64);\n\n    if (!psbt.validateSignaturesOfAllInputs())\n      throw new Error('Signatures not valid');\n\n    const msgAccept = proto.SwapAccept.deserializeBinary(message);\n    //Build SwapComplete\n    const msgComplete = new proto.SwapComplete();\n    msgComplete.setId(makeid(8));\n    msgComplete.setAcceptId(msgAccept.getId());\n    msgComplete.setTransaction(psetBase64);\n\n    if (this.verbose) console.log(msgAccept.toObject());\n\n    return msgComplete.serializeBinary();\n  }\n}\n\n/**\n * Take a swap messages and check if the message's data is corresponding to the  msg's transaction.\n * @param msgRequest the swap request message.\n * @param msgAccept the swap accept message.\n */\nasync function compareMessagesAndTransaction(\n  msgRequest: proto.SwapRequest,\n  msgAccept?: proto.SwapAccept\n): Promise<void> {\n  // decode the transaction.\n  const decodedFromRequest = decodePsbt(msgRequest.getTransaction());\n\n  // nonWitnessUtxo to witnessUtxoutxos\n  decodedFromRequest.psbt.data.inputs.forEach((i: any, inputIndex: number) => {\n    if (!i.witnessUtxo && i.nonWitnessUtxo) {\n      const vout: number = decodedFromRequest.transaction.ins[inputIndex].index;\n      const witnessUtxo: TxOutput = Transaction.fromHex(i.nonWitnessUtxo).outs[\n        vout\n      ];\n      i.witnessUtxo = witnessUtxo;\n    }\n  });\n\n  // check the amount of the transaction\n  const totalP = await countUtxos(\n    decodedFromRequest.psbt.data.inputs,\n    msgRequest.getAssetP(),\n    blindKeysMap(msgRequest.getInputBlindingKeyMap())\n  );\n\n  if (totalP < msgRequest.getAmountP()) {\n    throw new Error(\n      'Cumulative utxos count is not enough to cover SwapRequest.amount_p'\n    );\n  }\n\n  // check if the output if found in the transaction\n  const outputRFound: boolean = await outputFoundInTransaction(\n    decodedFromRequest.transaction.outs,\n    msgRequest.getAmountR(),\n    msgRequest.getAssetR(),\n    blindKeysMap(msgRequest.getOutputBlindingKeyMap())\n  );\n\n  if (!outputRFound)\n    throw new Error(\n      `Either SwapRequest.amount_r or SwapRequest.asset_r do not match the provided psbt (amount: ${msgRequest.getAmountR()}, asset: ${msgRequest.getAssetR()})`\n    );\n\n  // msg accept\n  if (msgAccept) {\n    // decode the tx and check the msg's ids\n    const decodedFromAccept = decodePsbt(msgAccept.getTransaction());\n    if (msgRequest.getId() !== msgAccept.getRequestId())\n      throw new Error(\n        'SwapRequest.id and SwapAccept.request_id are not the same'\n      );\n\n    // check the amount of utxos.\n    const totalR = await countUtxos(\n      decodedFromAccept.psbt.data.inputs,\n      msgRequest.getAssetR(),\n      blindKeysMap(msgAccept.getInputBlindingKeyMap())\n    );\n\n    if (totalR < msgRequest.getAmountR()) {\n      throw new Error(\n        'Cumulative utxos count is not enough to cover SwapRequest.amount_r'\n      );\n    }\n\n    // check if there is an output found in the transaction.\n    const outputPFound = outputFoundInTransaction(\n      decodedFromAccept.transaction.outs,\n      msgRequest.getAmountP(),\n      msgRequest.getAssetP(),\n      blindKeysMap(msgAccept.getOutputBlindingKeyMap())\n    );\n\n    if (!outputPFound)\n      throw new Error(\n        `Either SwapRequest.amount_p or SwapRequest.asset_p do not match the provided psbt amount=${msgRequest.getAmountP()} asset=${msgRequest.getAssetP()}`\n      );\n  }\n}\n\n/**\n * find an output in outputs corresponding to value and asset. Provide outputBlindKeys if output are blinded.\n * @param outputs the outputs to search in.\n * @param value value of the output.\n * @param asset hex encoded asset of the output.\n * @param outputBlindKeys optional, only if blinded outputs. Blinding keys map (scriptPukKey -> blindingKey).\n */\nasync function outputFoundInTransaction(\n  outputs: Array<TxOutput>,\n  value: number,\n  asset: string,\n  outputBlindKeys: BlindKeysMap = {}\n): Promise<boolean> {\n  return outputs.some(async (o: TxOutput) => {\n    // unblind first if confidential ouput\n    const isConfidential = isConfidentialOutput(o);\n    if (isConfidential === true) {\n      const blindKey: Buffer = outputBlindKeys[o.script.toString('hex')];\n      // if no blinding keys for the confidential ouput --> return false\n      if (blindKey === undefined)\n        throw new Error(`no blind key for ${o.script.toString('hex')}`);\n      try {\n        const {\n          value: unblindValue,\n          asset: unblindAsset,\n        } = await unblindOutput(\n          {\n            blindedAsset: o.asset,\n            blindedValue: o.value,\n            script: o.script.toString('hex'),\n            surjectionProof: o.surjectionProof!,\n            rangeProof: o.rangeProof!,\n            nonce: o.nonce,\n          },\n          blindKey.toString('hex')\n        );\n        // check unblind value and unblind asset\n        return unblindValue === value && unblindAsset === asset;\n      } catch (_) {\n        // if unblind fail --> return false\n        return false;\n      }\n    }\n    // check value and asset\n    const assetBuffer: Buffer = Buffer.from(asset, 'hex').reverse();\n    const isAsset: boolean = assetBuffer.equals(o.asset.slice(1));\n    const isValue: boolean =\n      confidential.confidentialValueToSatoshi(o.value) === value;\n    return isAsset && isValue;\n  });\n}\n\n/**\n * Returns the sum of the values of the given inputs' utxos.\n * @param utxos the inputs.\n * @param asset the asset to fetch value.\n * @param inputBlindKeys optional, the blinding keys using to unblind witnessUtxo if blinded.\n */\nasync function countUtxos(\n  utxos: Array<any>,\n  asset: string,\n  inputBlindKeys: BlindKeysMap = {}\n): Promise<number> {\n  const assetBuffer: Buffer = Buffer.from(asset, 'hex').reverse();\n  const filteredByWitness = utxos.filter((i: any) => i.witnessUtxo != null);\n\n  // unblind confidential prevouts\n  const unblindedUtxos: any[] = await Promise.all(\n    filteredByWitness.map(async (i: any) => {\n      if (i.witnessUtxo && isConfidentialOutput(i.witnessUtxo)) {\n        const blindKey = inputBlindKeys[i.witnessUtxo.script.toString('hex')];\n        if (blindKey === undefined) {\n          throw new Error(\n            'no blindKey for script: ' + i.witnessUtxo.script.toString('hex')\n          );\n        }\n        const {\n          value: unblindValue,\n          asset: unblindAsset,\n        } = await unblindOutput(\n          {\n            blindedAsset: i.witnessUtxo.asset,\n            blindedValue: i.witnessUtxo.value,\n            script: i.witnessUtxo.script.toString('hex'),\n            surjectionProof: i.witnessUtxo.surjectionProof!,\n            rangeProof: i.witnessUtxo.rangeProof!,\n            nonce: i.witnessUtxo.nonce,\n          },\n          blindKey.toString('hex')\n        );\n        i.value = unblindValue;\n        i.asset = unblindAsset;\n        i.witnessUtxo.value = unblindValue;\n      }\n      return i;\n    })\n  );\n\n  // filter inputs by asset and return the the count\n  const filteredByAsset = unblindedUtxos.filter((i: any) => {\n    return (\n      assetBuffer.equals(i.witnessUtxo.asset.slice(1)) || i.asset === asset\n    );\n  });\n\n  const queryValues = filteredByAsset.map((i: any) => {\n    const valAsNumber: number =\n      i.witnessUtxo.value instanceof Buffer\n        ? confidential.confidentialValueToSatoshi(i.witnessUtxo!.value)\n        : i.witnessUtxo!.value;\n    return valAsNumber;\n  });\n\n  // apply reducer to values (add the values)\n  return queryValues.reduce((a: any, b: any) => a + b, 0);\n}\n\nfunction parse({\n  message,\n  type,\n}: {\n  message: Uint8Array;\n  type: string;\n}): string {\n  let msg: any;\n  try {\n    msg = (proto as any)[type].deserializeBinary(message);\n  } catch (e) {\n    throw new Error(`Not valid message of expected type ${type}`);\n  }\n\n  return JSON.stringify(msg.toObject(), undefined, 2);\n}\n\n/**\n * Convert jspb's Map type to BlindKeysMap.\n * @param jspbMap the map to convert.\n */\nexport function blindKeysMap(\n  jspbMap: jspb.Map<string, string | Uint8Array>\n): BlindKeysMap | undefined {\n  const map: BlindKeysMap = {};\n  jspbMap.forEach((entry: string | Uint8Array, key: string) => {\n    const value: Buffer =\n      entry instanceof Uint8Array\n        ? Buffer.from(entry)\n        : Buffer.from(entry, 'hex');\n\n    map[key] = value;\n  });\n  return map;\n}\n","import * as services from 'tdex-protobuf/generated/js/TradeServiceClientPb';\nimport * as messages from 'tdex-protobuf/generated/js/trade_pb';\nimport * as types from 'tdex-protobuf/generated/js/types_pb';\nimport { SwapRequest, SwapComplete } from 'tdex-protobuf/generated/js/swap_pb';\n\nimport TraderClientInterface from './grpcClientInterface';\n\nimport { getClearTextTorProxyUrl } from './utils';\n\nexport class TraderClient implements TraderClientInterface {\n  providerUrl: string;\n  client: services.TradeClient;\n\n  constructor(providerUrl: string) {\n    this.providerUrl = providerUrl;\n    const url = new URL(providerUrl);\n\n    // we assume we are in Liquid mainnet\n    // TODO check if socks5 proxy is running (ie. Tor Browser)\n    if (url.hostname.includes('onion') && !url.protocol.includes('https')) {\n      // We use the HTTP1 cleartext endpoint here provided by the public tor reverse proxy\n      // https://pkg.go.dev/github.com/tdex-network/tor-proxy@v0.0.3/pkg/torproxy#NewTorProxy\n      //host:port/<just_onion_host_without_dot_onion>/[<grpc_package>.<grpc_service>/<grpc_method>]\n      let torProxyEndpoint =\n        process.env.TOR_PROXY_ENDPOINT || 'https://proxy.tdex.network';\n      this.providerUrl = getClearTextTorProxyUrl(torProxyEndpoint, url);\n    }\n\n    this.client = new services.TradeClient(this.providerUrl);\n  }\n\n  /**\n   * tradePropose\n   * @param market\n   * @param tradeType\n   * @param swapRequestSerialized\n   */\n  tradePropose(\n    { baseAsset, quoteAsset }: any,\n    tradeType: number,\n    swapRequestSerialized: Uint8Array\n  ): Promise<Uint8Array> {\n    return new Promise((resolve, reject) => {\n      const market = new types.Market();\n      market.setBaseAsset(baseAsset);\n      market.setQuoteAsset(quoteAsset);\n\n      const request = new messages.TradeProposeRequest();\n      request.setMarket(market);\n      request.setType(tradeType);\n      request.setSwapRequest(\n        SwapRequest.deserializeBinary(swapRequestSerialized)\n      );\n\n      const call = this.client.tradePropose(request);\n\n      let data: Uint8Array;\n      call.on('data', (reply: messages.TradeProposeReply) => {\n        throwErrorIfSwapFail(reply);\n        const swapAcceptMsg = reply!.getSwapAccept();\n        data = swapAcceptMsg!.serializeBinary();\n      });\n\n      call.on('end', () => resolve(data));\n      call.on('error', (e: any) => reject(e));\n    });\n  }\n\n  /**\n   * tradeComplete\n   * @param swapCompleteSerialized\n   */\n  tradeComplete(swapCompleteSerialized: Uint8Array): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const request = new messages.TradeCompleteRequest();\n      request.setSwapComplete(\n        SwapComplete.deserializeBinary(swapCompleteSerialized)\n      );\n      const call = this.client.tradeComplete(request);\n      let data: string;\n      call.on('data', (reply: messages.TradeCompleteReply) => {\n        throwErrorIfSwapFail(reply);\n        data = reply!.getTxid();\n      });\n      call.on('end', () => resolve(data));\n      call.on('error', (e: any) => reject(e));\n    });\n  }\n\n  markets(): Promise<\n    Array<{ baseAsset: string; quoteAsset: string; feeBasisPoint: number }>\n  > {\n    return new Promise((resolve, reject) => {\n      this.client.markets(\n        new messages.MarketsRequest(),\n        null,\n        (err, response) => {\n          if (err) return reject(err);\n          const list = response!\n            .getMarketsList()\n            .map((mktWithFee: types.MarketWithFee) => ({\n              baseAsset: mktWithFee!.getMarket()!.getBaseAsset(),\n              quoteAsset: mktWithFee!.getMarket()!.getQuoteAsset(),\n              feeBasisPoint: mktWithFee!.getFee()!.getBasisPoint(),\n            }));\n          resolve(list);\n        }\n      );\n    });\n  }\n\n  marketPrice(\n    {\n      baseAsset,\n      quoteAsset,\n    }: {\n      baseAsset: string;\n      quoteAsset: string;\n    },\n    tradeType: number,\n    amount: number,\n    asset: string\n  ): Promise<Array<types.PriceWithFee.AsObject>> {\n    const market = new types.Market();\n    market.setBaseAsset(baseAsset);\n    market.setQuoteAsset(quoteAsset);\n    const request = new messages.MarketPriceRequest();\n    request.setMarket(market);\n    request.setType(tradeType);\n    request.setAmount(amount);\n    request.setAsset(asset);\n\n    return new Promise((resolve, reject) => {\n      this.client.marketPrice(request, null, (err, response) => {\n        if (err) return reject(err);\n\n        const list = response\n          .getPricesList()\n          .map((mktWithFee: types.PriceWithFee) => mktWithFee.toObject());\n\n        resolve(list);\n      });\n    });\n  }\n\n  balances({\n    baseAsset,\n    quoteAsset,\n  }: {\n    baseAsset: string;\n    quoteAsset: string;\n  }): Promise<Array<types.BalanceWithFee.AsObject>> {\n    const market = new types.Market();\n    market.setBaseAsset(baseAsset);\n    market.setQuoteAsset(quoteAsset);\n    const request = new messages.BalancesRequest();\n    request.setMarket(market);\n\n    return new Promise((resolve, reject) => {\n      this.client.balances(request, null, (err, response) => {\n        if (err) return reject(err);\n\n        const reply = response\n          .getBalancesList()\n          .map((balanceWithFee: types.BalanceWithFee) =>\n            balanceWithFee.toObject()\n          );\n\n        resolve(reply);\n      });\n    });\n  }\n}\n\nexport function throwErrorIfSwapFail(\n  tradeReply: messages.TradeProposeReply | messages.TradeCompleteReply\n) {\n  const swapFail = tradeReply.getSwapFail();\n  if (swapFail) {\n    const errorMessage = `SwapFail for message id=${swapFail.getId()}. Failure code ${swapFail.getFailureCode()} | reason: ${swapFail.getFailureMessage()}`;\n    throw new Error(errorMessage);\n  }\n}\n","import {\n  greedyCoinSelector,\n  UtxoInterface,\n  networks,\n  address,\n  RecipientInterface,\n  IdentityInterface,\n  CoinSelector,\n} from 'ldk';\nimport { confidential, Psbt } from 'liquidjs-lib';\n\n// SwapTransactionInterface defines the minimum needed for implementation to hold data to construct a valid swap transaction.\ninterface SwapTransactionInterface {\n  network: networks.Network;\n  pset: Psbt;\n  inputBlindingKeys: Record<string, Buffer>;\n  outputBlindingKeys: Record<string, Buffer>;\n}\n\n// SwapTransaction holds a pset and expose a create method to select coins and build a transaction for a SwapRequest message\nexport class SwapTransaction implements SwapTransactionInterface {\n  network: networks.Network;\n  pset: Psbt;\n  inputBlindingKeys: Record<string, Buffer> = {};\n  outputBlindingKeys: Record<string, Buffer> = {};\n\n  private identity: IdentityInterface;\n\n  constructor(identity: IdentityInterface) {\n    this.identity = identity;\n    this.network = identity.network;\n    this.pset = new Psbt({ network: this.network });\n  }\n\n  create(\n    unspents: Array<UtxoInterface>,\n    amountToBeSent: number,\n    amountToReceive: number,\n    assetToBeSent: string,\n    assetToReceive: string,\n    addressForSwapOutput: string,\n    addressForChangeOutput: string,\n    coinSelector: CoinSelector = greedyCoinSelector()\n  ) {\n    const { selectedUtxos, changeOutputs } = coinSelector(\n      unspents,\n      [\n        {\n          value: amountToBeSent,\n          asset: assetToBeSent,\n          address: '',\n        },\n      ],\n      (_: string) => addressForChangeOutput\n    );\n\n    selectedUtxos.forEach((i: UtxoInterface) => {\n      this.pset.addInput({\n        // if hash is string, txid, if hash is Buffer, is reversed compared to txid\n        hash: i.txid,\n        index: i.vout,\n        //We put here the blinded prevout\n        witnessUtxo: i.prevout,\n      });\n\n      if (!i.prevout) {\n        throw new Error(\n          'create tx: missing prevout member for input ' + i.txid + ':' + i.vout\n        );\n      }\n\n      // we update the inputBlindingKeys map after we add an input to the transaction\n      const scriptHex = i.prevout.script.toString('hex');\n      this.inputBlindingKeys[scriptHex] = Buffer.from(\n        this.identity.getBlindingPrivateKey(scriptHex),\n        'hex'\n      );\n    });\n\n    const receivingScript = address\n      .toOutputScript(addressForSwapOutput, this.network)\n      .toString('hex');\n\n    // The receiving output\n    this.pset.addOutput({\n      script: receivingScript,\n      value: confidential.satoshiToConfidentialValue(amountToReceive),\n      asset: assetToReceive,\n      nonce: Buffer.from('00', 'hex'),\n    });\n\n    // we update the outputBlindingKeys map after we add the receiving output to the transaction\n    this.outputBlindingKeys[receivingScript] = Buffer.from(\n      this.identity.getBlindingPrivateKey(receivingScript),\n      'hex'\n    );\n\n    if (changeOutputs.length > 0) {\n      changeOutputs.forEach((changeOutput: RecipientInterface) => {\n        const changeScript = address\n          .toOutputScript(changeOutput.address, this.network)\n          .toString('hex');\n\n        // Change\n        this.pset.addOutput({\n          script: changeScript,\n          value: confidential.satoshiToConfidentialValue(changeOutput.value),\n          asset: changeOutput.asset,\n          nonce: Buffer.from('00', 'hex'),\n        });\n\n        // we update the outputBlindingKeys map after we add the change output to the transaction\n        this.outputBlindingKeys[changeScript] = Buffer.from(\n          this.identity.getBlindingPrivateKey(changeScript),\n          'hex'\n        );\n      });\n    }\n  }\n}\n","import Core, { CoreInterface } from './core';\nimport { Swap } from './swap';\nimport {\n  UtxoInterface,\n  IdentityInterface,\n  CoinSelector,\n  isValidAmount,\n} from 'ldk';\nimport TraderClientInterface from './grpcClientInterface';\nimport { SwapAccept } from 'tdex-protobuf/generated/js/swap_pb';\nimport { SwapTransaction } from './transaction';\n\nexport interface MarketInterface {\n  baseAsset: string;\n  quoteAsset: string;\n}\n\nexport interface TradeInterface extends CoreInterface {\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n}\n\nexport enum TradeType {\n  BUY = 0,\n  SELL = 1,\n}\n\nexport interface TradeOpts {\n  providerUrl: string;\n  explorerUrl: string;\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n}\n\nexport interface BuySellOpts {\n  market: MarketInterface;\n  amount: number;\n  asset: string;\n  identity: IdentityInterface;\n}\n\ntype TraderClientInterfaceFactory = (\n  providerUrl: string\n) => TraderClientInterface;\n\nexport class TradeCore extends Core implements TradeInterface {\n  grpcClient: TraderClientInterface;\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n\n  constructor(\n    args: TradeOpts,\n    factoryTraderClient: TraderClientInterfaceFactory\n  ) {\n    super(args);\n\n    this.validate(args);\n    this.utxos = args.utxos;\n    this.coinSelector = args.coinSelector;\n    this.grpcClient = factoryTraderClient(args.providerUrl);\n  }\n\n  validate(args: TradeOpts) {\n    if (!this.providerUrl)\n      throw new Error(\n        'To be able to trade you need to select a liquidity provider via { providerUrl }'\n      );\n\n    if (!this.explorerUrl)\n      throw new Error(\n        'To be able to trade you need to select an explorer via { explorerUrl }'\n      );\n\n    if (args.utxos.length <= 0) {\n      throw new Error('You need at least one utxo to trade');\n    }\n  }\n\n  /**\n   * Trade.buy let the trader buy the baseAsset,\n   * sending his own quoteAsset using the current market price\n   */\n  async buy({ market, amount, asset, identity }: BuySellOpts): Promise<string> {\n    const swapAccept = await this.marketOrderRequest(\n      market,\n      TradeType.BUY,\n      amount,\n      asset,\n      identity\n    );\n    const txid = await this.marketOrderComplete(swapAccept, identity);\n    return txid;\n  }\n\n  /**\n   * Trade.sell let the trader sell the baseAsset,\n   * receiving the quoteAsset using the current market price\n   */\n  async sell({\n    market,\n    amount,\n    asset,\n    identity,\n  }: BuySellOpts): Promise<string> {\n    const swapAccept = await this.marketOrderRequest(\n      market,\n      TradeType.SELL,\n      amount,\n      asset,\n      identity\n    );\n    const txid = await this.marketOrderComplete(swapAccept, identity);\n    return txid;\n  }\n\n  async preview({\n    market,\n    tradeType,\n    amount,\n    asset,\n  }: {\n    market: MarketInterface;\n    tradeType: TradeType;\n    amount: number;\n    asset: string;\n  }): Promise<{\n    assetToBeSent: string;\n    amountToBeSent: number;\n    assetToReceive: string;\n    amountToReceive: number;\n  }> {\n    if (!isValidAmount(amount)) {\n      throw new Error('Amount is not valid');\n    }\n    const { baseAsset, quoteAsset } = market;\n\n    const prices = await this.grpcClient.marketPrice(\n      {\n        baseAsset,\n        quoteAsset,\n      },\n      tradeType,\n      amount,\n      asset\n    );\n\n    const previewedAmount = prices[0].amount;\n    if (tradeType === TradeType.BUY) {\n      return {\n        assetToBeSent: quoteAsset,\n        amountToBeSent: asset === baseAsset ? previewedAmount : amount,\n        assetToReceive: baseAsset,\n        amountToReceive: asset === baseAsset ? amount : previewedAmount,\n      };\n    }\n\n    return {\n      assetToBeSent: baseAsset,\n      amountToBeSent: asset === quoteAsset ? previewedAmount : amount,\n      assetToReceive: quoteAsset,\n      amountToReceive: asset === quoteAsset ? amount : previewedAmount,\n    };\n  }\n\n  private async marketOrderRequest(\n    market: MarketInterface,\n    tradeType: TradeType,\n    amountInSatoshis: number,\n    assetHash: string,\n    identity: IdentityInterface\n  ): Promise<Uint8Array> {\n    const {\n      assetToBeSent,\n      amountToBeSent,\n      assetToReceive,\n      amountToReceive,\n    } = await this.preview({\n      market,\n      tradeType,\n      amount: amountInSatoshis,\n      asset: assetHash,\n    });\n\n    const addressForOutput = identity.getNextAddress();\n    const addressForChange = identity.getNextChangeAddress();\n\n    const swapTx = new SwapTransaction(identity);\n    swapTx.create(\n      this.utxos,\n      amountToBeSent,\n      amountToReceive,\n      assetToBeSent,\n      assetToReceive,\n      addressForOutput.confidentialAddress,\n      addressForChange.confidentialAddress\n    );\n\n    const swap = new Swap();\n    const swapRequestSerialized = await swap.request({\n      assetToBeSent,\n      amountToBeSent,\n      assetToReceive,\n      amountToReceive,\n      psetBase64: swapTx.pset.toBase64(),\n      inputBlindingKeys: swapTx.inputBlindingKeys,\n      outputBlindingKeys: swapTx.outputBlindingKeys,\n    });\n\n    // 0 === Buy === receiving base_asset; 1 === sell === receiving base_asset\n    const swapAcceptSerialized: Uint8Array = await this.grpcClient.tradePropose(\n      market,\n      tradeType,\n      swapRequestSerialized\n    );\n\n    return swapAcceptSerialized;\n  }\n\n  private async marketOrderComplete(\n    swapAcceptSerialized: Uint8Array,\n    identity: IdentityInterface\n  ): Promise<string> {\n    // trader need to check the signed inputs by the provider\n    // and add his own inputs if all is correct\n    const swapAcceptMessage = SwapAccept.deserializeBinary(\n      swapAcceptSerialized\n    );\n    const transaction = swapAcceptMessage.getTransaction();\n    const signedPset = await identity.signPset(transaction);\n\n    // Trader  adds his signed inputs to the transaction\n    const swap = new Swap();\n    const swapCompleteSerialized = swap.complete({\n      message: swapAcceptSerialized,\n      psetBase64: signedPset,\n    });\n\n    // Trader call the tradeComplete endpoint to finalize the swap\n    const txid = await this.grpcClient.tradeComplete(swapCompleteSerialized);\n    return txid;\n  }\n}\n","import { TraderClient } from './grpcClient.web';\nimport { TradeCore, TradeInterface, TradeOpts } from './trade-core';\n\nexport class Trade extends TradeCore implements TradeInterface {\n  constructor(args: TradeOpts) {\n    super(args, (provider: string) => new TraderClient(provider));\n  }\n}\n"],"names":["Core","data","Object","assign","makeid","length","result","characters","charactersLength","i","charAt","Math","floor","random","decodePsbt","psetBase64","psbt","Psbt","fromBase64","ignore","Error","bufferTx","globalMap","unsignedTx","toBuffer","transaction","Transaction","fromBuffer","getClearTextTorProxyUrl","torProxyEndpoint","url","splitted","hostname","split","pop","onionPubKey","join","countUtxos","utxos","asset","inputBlindKeys","assetBuffer","Buffer","from","reverse","filteredByWitness","filter","witnessUtxo","Promise","all","map","isConfidentialOutput","blindKey","script","toString","undefined","unblindOutput","blindedAsset","blindedValue","value","surjectionProof","rangeProof","nonce","unblindValue","unblindAsset","unblindedUtxos","filteredByAsset","equals","slice","queryValues","valAsNumber","confidential","confidentialValueToSatoshi","reduce","a","b","outputFoundInTransaction","outputs","outputBlindKeys","some","o","isAsset","isValue","isConfidential","compareMessagesAndTransaction","msgRequest","msgAccept","decodedFromRequest","getTransaction","inputs","forEach","inputIndex","nonWitnessUtxo","vout","ins","index","fromHex","outs","getAssetP","blindKeysMap","getInputBlindingKeyMap","totalP","getAmountP","getAmountR","getAssetR","getOutputBlindingKeyMap","outputRFound","decodedFromAccept","getId","getRequestId","totalR","outputPFound","Swap","request","amountToBeSent","assetToBeSent","amountToReceive","assetToReceive","inputBlindingKeys","outputBlindingKeys","msg","proto","setId","setAmountP","setAssetP","setAmountR","setAssetR","setTransaction","entries","key","set","Uint8Array","verbose","console","log","toObject","serializeBinary","accept","message","deserializeBinary","setRequestId","complete","validateSignaturesOfAllInputs","msgComplete","setAcceptId","parse","type","e","JSON","stringify","jspbMap","entry","TraderClient","providerUrl","URL","includes","protocol","process","env","TOR_PROXY_ENDPOINT","client","services","tradePropose","tradeType","swapRequestSerialized","baseAsset","quoteAsset","resolve","reject","market","types","setBaseAsset","setQuoteAsset","messages","setMarket","setType","setSwapRequest","SwapRequest","call","on","reply","throwErrorIfSwapFail","swapAcceptMsg","getSwapAccept","tradeComplete","swapCompleteSerialized","setSwapComplete","SwapComplete","getTxid","markets","err","response","list","getMarketsList","mktWithFee","getMarket","getBaseAsset","getQuoteAsset","feeBasisPoint","getFee","getBasisPoint","marketPrice","amount","setAmount","setAsset","getPricesList","balances","getBalancesList","balanceWithFee","tradeReply","swapFail","getSwapFail","errorMessage","getFailureCode","getFailureMessage","SwapTransaction","identity","network","pset","create","unspents","addressForSwapOutput","addressForChangeOutput","coinSelector","greedyCoinSelector","address","_","selectedUtxos","changeOutputs","addInput","hash","txid","prevout","scriptHex","getBlindingPrivateKey","receivingScript","toOutputScript","addOutput","satoshiToConfidentialValue","changeOutput","changeScript","TradeType","TradeCore","args","factoryTraderClient","validate","grpcClient","explorerUrl","buy","marketOrderRequest","BUY","swapAccept","marketOrderComplete","sell","SELL","preview","isValidAmount","prices","previewedAmount","amountInSatoshis","assetHash","addressForOutput","getNextAddress","addressForChange","getNextChangeAddress","swapTx","confidentialAddress","swap","toBase64","swapAcceptSerialized","swapAcceptMessage","SwapAccept","signPset","signedPset","Trade","provider"],"mappings":"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"}