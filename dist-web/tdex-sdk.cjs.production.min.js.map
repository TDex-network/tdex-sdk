{"version":3,"file":"tdex-sdk.cjs.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/core.ts","../src/utils.ts","../src/swap.ts","../src/grpcClient.web.ts","../src/trade-core.ts","../src/transaction.ts","../src/trade.web.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export interface CoreInterface {\n  verbose?: Boolean;\n  chain?: string;\n  providerUrl?: string;\n  explorerUrl?: string;\n}\n\nexport default class Core {\n  public verbose?: Boolean = false;\n  public chain?: string = 'regtest';\n  public providerUrl?: string;\n  public explorerUrl?: string;\n\n  constructor(data?: SafePick<Core>) {\n    Object.assign(this, data);\n  }\n}\n\ntype NonMethodKeys<T> = ({\n  [P in keyof T]: T[P] extends Function ? never : P;\n} & { [x: string]: never })[keyof T];\ntype SafePick<T> = Pick<T, NonMethodKeys<T>>;\n","import { Psbt, Transaction } from 'liquidjs-lib';\n\n/**\n * Generates a random id of a fixed length.\n * @param length size of the string id.\n */\nexport function makeid(length: number): string {\n  let result = '';\n  const characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport function decodePsbt(\n  psetBase64: string\n): { psbt: Psbt; transaction: Transaction } {\n  let psbt: Psbt;\n  try {\n    psbt = Psbt.fromBase64(psetBase64);\n  } catch (ignore) {\n    throw new Error('Invalid psbt');\n  }\n\n  const bufferTx = psbt.data.globalMap.unsignedTx.toBuffer();\n  const transaction = Transaction.fromBuffer(bufferTx);\n  return {\n    psbt,\n    transaction,\n  };\n}\n\nexport function getClearTextTorProxyUrl(\n  torProxyEndpoint: string,\n  url: URL\n): string {\n  // get just_onion_host_without_dot_onion\n  const splitted = url.hostname.split('.');\n  splitted.pop();\n  const onionPubKey = splitted.join('.');\n\n  return `${torProxyEndpoint}/${onionPubKey}`;\n}\n","import Core from './core';\nimport { confidential, TxOutput, Transaction } from 'liquidjs-lib';\nimport * as proto from 'tdex-protobuf/generated/js/swap_pb';\nimport * as jspb from 'google-protobuf';\nimport { isConfidentialOutput, unblindOutput } from 'ldk';\nimport { makeid, decodePsbt } from './utils';\n\n// type for BlindingKeys\ntype BlindKeysMap = Record<string, Buffer>;\n\n// define the Swap.request arguments.\ninterface requestOpts {\n  assetToBeSent: string;\n  amountToBeSent: number;\n  assetToReceive: string;\n  amountToReceive: number;\n  psetBase64: string;\n  inputBlindingKeys?: BlindKeysMap;\n  outputBlindingKeys?: BlindKeysMap;\n}\n\n// define the Swap.accept arguments.\ninterface acceptOpts {\n  message: Uint8Array;\n  psetBase64: string;\n  inputBlindingKeys?: BlindKeysMap;\n  outputBlindingKeys?: BlindKeysMap;\n}\n\n/**\n * The Swap class implements the Swap TDEX protocol i.e swap.request, swap.accept and swap.complete.\n * @see https://github.com/TDex-network/tdex-specs/blob/master/03-swap-protocol.md\n */\nexport class Swap extends Core {\n  static parse = parse;\n\n  /**\n   * Create and serialize a SwapRequest Message.\n   * @param args the args of swap.request see requestOpts.\n   */\n  async request({\n    amountToBeSent,\n    assetToBeSent,\n    amountToReceive,\n    assetToReceive,\n    psetBase64,\n    inputBlindingKeys,\n    outputBlindingKeys,\n  }: requestOpts): Promise<Uint8Array> {\n    // Check amounts\n    const msg = new proto.SwapRequest();\n    msg.setId(makeid(8));\n    msg.setAmountP(amountToBeSent);\n    msg.setAssetP(assetToBeSent);\n    msg.setAmountR(amountToReceive);\n    msg.setAssetR(assetToReceive);\n    msg.setTransaction(psetBase64);\n\n    if (inputBlindingKeys) {\n      // set the input blinding keys\n      Object.entries(inputBlindingKeys).forEach(([key, value]) => {\n        msg.getInputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    if (outputBlindingKeys) {\n      // set the output blinding keys\n      Object.entries(outputBlindingKeys).forEach(([key, value]) => {\n        msg.getOutputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    // check the message content and transaction.\n    await compareMessagesAndTransaction(msg);\n\n    if (this.verbose) console.log(msg.toObject());\n\n    return msg.serializeBinary();\n  }\n\n  /**\n   * Create and serialize an accept message.\n   * @param args the Swap.accept args, see AcceptOpts.\n   */\n  async accept({\n    message,\n    psetBase64,\n    inputBlindingKeys,\n    outputBlindingKeys,\n  }: acceptOpts): Promise<Uint8Array> {\n    // deserialize message parameter to get the SwapRequest message.\n    const msgRequest = proto.SwapRequest.deserializeBinary(message);\n    // Build Swap Accept message\n    const msgAccept = new proto.SwapAccept();\n    msgAccept.setId(makeid(8));\n    msgAccept.setRequestId(msgRequest.getId());\n    msgAccept.setTransaction(psetBase64);\n\n    if (inputBlindingKeys) {\n      // set the input blinding keys\n      Object.entries(inputBlindingKeys).forEach(([key, value]) => {\n        msgAccept.getInputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    if (outputBlindingKeys) {\n      // set the output blinding keys\n      Object.entries(outputBlindingKeys).forEach(([key, value]) => {\n        msgAccept.getOutputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    // compare messages and transaction data\n    await compareMessagesAndTransaction(msgRequest, msgAccept);\n\n    if (this.verbose) console.log(msgAccept.toObject());\n\n    // serialize the SwapAccept message.\n    return msgAccept.serializeBinary();\n  }\n\n  /**\n   * create and serialize a SwapComplete message.\n   * @param args contains the SwapAccept message + the base64 encoded transaction.\n   */\n  complete({\n    message,\n    psetBase64,\n  }: {\n    message: Uint8Array;\n    psetBase64: string;\n  }): Uint8Array {\n    //First validate signatures\n    const { psbt } = decodePsbt(psetBase64);\n\n    if (!psbt.validateSignaturesOfAllInputs())\n      throw new Error('Signatures not valid');\n\n    const msgAccept = proto.SwapAccept.deserializeBinary(message);\n    //Build SwapComplete\n    const msgComplete = new proto.SwapComplete();\n    msgComplete.setId(makeid(8));\n    msgComplete.setAcceptId(msgAccept.getId());\n    msgComplete.setTransaction(psetBase64);\n\n    if (this.verbose) console.log(msgAccept.toObject());\n\n    return msgComplete.serializeBinary();\n  }\n}\n\n/**\n * Take a swap messages and check if the message's data is corresponding to the  msg's transaction.\n * @param msgRequest the swap request message.\n * @param msgAccept the swap accept message.\n */\nasync function compareMessagesAndTransaction(\n  msgRequest: proto.SwapRequest,\n  msgAccept?: proto.SwapAccept\n): Promise<void> {\n  // decode the transaction.\n  const decodedFromRequest = decodePsbt(msgRequest.getTransaction());\n\n  // nonWitnessUtxo to witnessUtxoutxos\n  decodedFromRequest.psbt.data.inputs.forEach((i: any, inputIndex: number) => {\n    if (!i.witnessUtxo && i.nonWitnessUtxo) {\n      const vout: number = decodedFromRequest.transaction.ins[inputIndex].index;\n      const witnessUtxo: TxOutput = Transaction.fromHex(i.nonWitnessUtxo).outs[\n        vout\n      ];\n      i.witnessUtxo = witnessUtxo;\n    }\n  });\n\n  // check the amount of the transaction\n  const totalP = await countUtxos(\n    decodedFromRequest.psbt.data.inputs,\n    msgRequest.getAssetP(),\n    blindKeysMap(msgRequest.getInputBlindingKeyMap())\n  );\n\n  if (totalP < msgRequest.getAmountP()) {\n    throw new Error(\n      'Cumulative utxos count is not enough to cover SwapRequest.amount_p'\n    );\n  }\n\n  // check if the output if found in the transaction\n  const outputRFound: boolean = await outputFoundInTransaction(\n    decodedFromRequest.transaction.outs,\n    msgRequest.getAmountR(),\n    msgRequest.getAssetR(),\n    blindKeysMap(msgRequest.getOutputBlindingKeyMap())\n  );\n\n  if (!outputRFound)\n    throw new Error(\n      `Either SwapRequest.amount_r or SwapRequest.asset_r do not match the provided psbt (amount: ${msgRequest.getAmountR()}, asset: ${msgRequest.getAssetR()})`\n    );\n\n  // msg accept\n  if (msgAccept) {\n    // decode the tx and check the msg's ids\n    const decodedFromAccept = decodePsbt(msgAccept.getTransaction());\n    if (msgRequest.getId() !== msgAccept.getRequestId())\n      throw new Error(\n        'SwapRequest.id and SwapAccept.request_id are not the same'\n      );\n\n    // check the amount of utxos.\n    const totalR = await countUtxos(\n      decodedFromAccept.psbt.data.inputs,\n      msgRequest.getAssetR(),\n      blindKeysMap(msgAccept.getInputBlindingKeyMap())\n    );\n\n    if (totalR < msgRequest.getAmountR()) {\n      throw new Error(\n        'Cumulative utxos count is not enough to cover SwapRequest.amount_r'\n      );\n    }\n\n    // check if there is an output found in the transaction.\n    const outputPFound = outputFoundInTransaction(\n      decodedFromAccept.transaction.outs,\n      msgRequest.getAmountP(),\n      msgRequest.getAssetP(),\n      blindKeysMap(msgAccept.getOutputBlindingKeyMap())\n    );\n\n    if (!outputPFound)\n      throw new Error(\n        `Either SwapRequest.amount_p or SwapRequest.asset_p do not match the provided psbt amount=${msgRequest.getAmountP()} asset=${msgRequest.getAssetP()}`\n      );\n  }\n}\n\n/**\n * find an output in outputs corresponding to value and asset. Provide outputBlindKeys if output are blinded.\n * @param outputs the outputs to search in.\n * @param value value of the output.\n * @param asset hex encoded asset of the output.\n * @param outputBlindKeys optional, only if blinded outputs. Blinding keys map (scriptPukKey -> blindingKey).\n */\nasync function outputFoundInTransaction(\n  outputs: Array<TxOutput>,\n  value: number,\n  asset: string,\n  outputBlindKeys: BlindKeysMap = {}\n): Promise<boolean> {\n  return outputs.some(async (o: TxOutput) => {\n    // unblind first if confidential ouput\n    const isConfidential = isConfidentialOutput(o);\n    if (isConfidential === true) {\n      const blindKey: Buffer = outputBlindKeys[o.script.toString('hex')];\n      // if no blinding keys for the confidential ouput --> return false\n      if (blindKey === undefined)\n        throw new Error(`no blind key for ${o.script.toString('hex')}`);\n      try {\n        const {\n          value: unblindValue,\n          asset: unblindAsset,\n        } = await unblindOutput(\n          {\n            blindedAsset: o.asset,\n            blindedValue: o.value,\n            script: o.script.toString('hex'),\n            surjectionProof: o.surjectionProof!,\n            rangeProof: o.rangeProof!,\n            nonce: o.nonce,\n          },\n          blindKey.toString('hex')\n        );\n        // check unblind value and unblind asset\n        return unblindValue === value && unblindAsset === asset;\n      } catch (_) {\n        // if unblind fail --> return false\n        return false;\n      }\n    }\n    // check value and asset\n    const assetBuffer: Buffer = Buffer.from(asset, 'hex').reverse();\n    const isAsset: boolean = assetBuffer.equals(o.asset.slice(1));\n    const isValue: boolean =\n      confidential.confidentialValueToSatoshi(o.value) === value;\n    return isAsset && isValue;\n  });\n}\n\n/**\n * Returns the sum of the values of the given inputs' utxos.\n * @param utxos the inputs.\n * @param asset the asset to fetch value.\n * @param inputBlindKeys optional, the blinding keys using to unblind witnessUtxo if blinded.\n */\nasync function countUtxos(\n  utxos: Array<any>,\n  asset: string,\n  inputBlindKeys: BlindKeysMap = {}\n): Promise<number> {\n  const assetBuffer: Buffer = Buffer.from(asset, 'hex').reverse();\n  const filteredByWitness = utxos.filter((i: any) => i.witnessUtxo != null);\n\n  // unblind confidential prevouts\n  const unblindedUtxos: any[] = await Promise.all(\n    filteredByWitness.map(async (i: any) => {\n      if (i.witnessUtxo && isConfidentialOutput(i.witnessUtxo)) {\n        const blindKey = inputBlindKeys[i.witnessUtxo.script.toString('hex')];\n        if (blindKey === undefined) {\n          throw new Error(\n            'no blindKey for script: ' + i.witnessUtxo.script.toString('hex')\n          );\n        }\n        const {\n          value: unblindValue,\n          asset: unblindAsset,\n        } = await unblindOutput(\n          {\n            blindedAsset: i.witnessUtxo.asset,\n            blindedValue: i.witnessUtxo.value,\n            script: i.witnessUtxo.script.toString('hex'),\n            surjectionProof: i.witnessUtxo.surjectionProof!,\n            rangeProof: i.witnessUtxo.rangeProof!,\n            nonce: i.witnessUtxo.nonce,\n          },\n          blindKey.toString('hex')\n        );\n        i.value = unblindValue;\n        i.asset = unblindAsset;\n        i.witnessUtxo.value = unblindValue;\n      }\n      return i;\n    })\n  );\n\n  // filter inputs by asset and return the the count\n  const filteredByAsset = unblindedUtxos.filter((i: any) => {\n    return (\n      assetBuffer.equals(i.witnessUtxo.asset.slice(1)) || i.asset === asset\n    );\n  });\n\n  const queryValues = filteredByAsset.map((i: any) => {\n    const valAsNumber: number =\n      i.witnessUtxo.value instanceof Buffer\n        ? confidential.confidentialValueToSatoshi(i.witnessUtxo!.value)\n        : i.witnessUtxo!.value;\n    return valAsNumber;\n  });\n\n  // apply reducer to values (add the values)\n  return queryValues.reduce((a: any, b: any) => a + b, 0);\n}\n\nfunction parse({\n  message,\n  type,\n}: {\n  message: Uint8Array;\n  type: string;\n}): string {\n  let msg: any;\n  try {\n    msg = (proto as any)[type].deserializeBinary(message);\n  } catch (e) {\n    throw new Error(`Not valid message of expected type ${type}`);\n  }\n\n  return JSON.stringify(msg.toObject(), undefined, 2);\n}\n\n/**\n * Convert jspb's Map type to BlindKeysMap.\n * @param jspbMap the map to convert.\n */\nexport function blindKeysMap(\n  jspbMap: jspb.Map<string, string | Uint8Array>\n): BlindKeysMap | undefined {\n  const map: BlindKeysMap = {};\n  jspbMap.forEach((entry: string | Uint8Array, key: string) => {\n    const value: Buffer =\n      entry instanceof Uint8Array\n        ? Buffer.from(entry)\n        : Buffer.from(entry, 'hex');\n\n    map[key] = value;\n  });\n  return map;\n}\n","import * as services from 'tdex-protobuf/generated/js/TradeServiceClientPb';\nimport * as messages from 'tdex-protobuf/generated/js/trade_pb';\nimport * as types from 'tdex-protobuf/generated/js/types_pb';\nimport { SwapRequest, SwapComplete } from 'tdex-protobuf/generated/js/swap_pb';\n\nimport TraderClientInterface from './grpcClientInterface';\n\nimport { getClearTextTorProxyUrl } from './utils';\n\nexport class TraderClient implements TraderClientInterface {\n  providerUrl: string;\n  client: services.TradeClient;\n\n  constructor(providerUrl: string) {\n    this.providerUrl = providerUrl;\n    const url = new URL(providerUrl);\n\n    // we assume we are in Liquid mainnet\n    // TODO check if socks5 proxy is running (ie. Tor Browser)\n    if (url.hostname.includes('onion') && !url.protocol.includes('https')) {\n      // We use the HTTP1 cleartext endpoint here provided by the public tor reverse proxy\n      // https://pkg.go.dev/github.com/tdex-network/tor-proxy@v0.0.3/pkg/torproxy#NewTorProxy\n      //host:port/<just_onion_host_without_dot_onion>/[<grpc_package>.<grpc_service>/<grpc_method>]\n      let torProxyEndpoint =\n        process.env.TOR_PROXY_ENDPOINT || 'https://proxy.tdex.network';\n      this.providerUrl = getClearTextTorProxyUrl(torProxyEndpoint, url);\n    }\n\n    this.client = new services.TradeClient(this.providerUrl);\n  }\n\n  /**\n   * tradePropose\n   * @param market\n   * @param tradeType\n   * @param swapRequestSerialized\n   */\n  tradePropose(\n    { baseAsset, quoteAsset }: any,\n    tradeType: number,\n    swapRequestSerialized: Uint8Array\n  ): Promise<Uint8Array> {\n    return new Promise((resolve, reject) => {\n      const market = new types.Market();\n      market.setBaseAsset(baseAsset);\n      market.setQuoteAsset(quoteAsset);\n\n      const request = new messages.TradeProposeRequest();\n      request.setMarket(market);\n      request.setType(tradeType);\n      request.setSwapRequest(\n        SwapRequest.deserializeBinary(swapRequestSerialized)\n      );\n\n      const call = this.client.tradePropose(request);\n\n      let data: Uint8Array;\n      call.on('data', (reply: messages.TradeProposeReply) => {\n        throwErrorIfSwapFail(reply);\n        const swapAcceptMsg = reply!.getSwapAccept();\n        data = swapAcceptMsg!.serializeBinary();\n      });\n\n      call.on('end', () => resolve(data));\n      call.on('error', (e: any) => reject(e));\n    });\n  }\n\n  /**\n   * tradeComplete\n   * @param swapCompleteSerialized\n   */\n  tradeComplete(swapCompleteSerialized: Uint8Array): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const request = new messages.TradeCompleteRequest();\n      request.setSwapComplete(\n        SwapComplete.deserializeBinary(swapCompleteSerialized)\n      );\n      const call = this.client.tradeComplete(request);\n      let data: string;\n      call.on('data', (reply: messages.TradeCompleteReply) => {\n        throwErrorIfSwapFail(reply);\n        data = reply!.getTxid();\n      });\n      call.on('end', () => resolve(data));\n      call.on('error', (e: any) => reject(e));\n    });\n  }\n\n  markets(): Promise<\n    Array<{ baseAsset: string; quoteAsset: string; feeBasisPoint: number }>\n  > {\n    return new Promise((resolve, reject) => {\n      this.client.markets(\n        new messages.MarketsRequest(),\n        null,\n        (err, response) => {\n          if (err) return reject(err);\n          const list = response!\n            .getMarketsList()\n            .map((mktWithFee: types.MarketWithFee) => ({\n              baseAsset: mktWithFee!.getMarket()!.getBaseAsset(),\n              quoteAsset: mktWithFee!.getMarket()!.getQuoteAsset(),\n              feeBasisPoint: mktWithFee!.getFee()!.getBasisPoint(),\n            }));\n          resolve(list);\n        }\n      );\n    });\n  }\n\n  marketPrice(\n    {\n      baseAsset,\n      quoteAsset,\n    }: {\n      baseAsset: string;\n      quoteAsset: string;\n    },\n    tradeType: number,\n    amount: number,\n    asset: string\n  ): Promise<Array<types.PriceWithFee.AsObject>> {\n    const market = new types.Market();\n    market.setBaseAsset(baseAsset);\n    market.setQuoteAsset(quoteAsset);\n    const request = new messages.MarketPriceRequest();\n    request.setMarket(market);\n    request.setType(tradeType);\n    request.setAmount(amount);\n    request.setAsset(asset);\n\n    return new Promise((resolve, reject) => {\n      this.client.marketPrice(request, null, (err, response) => {\n        if (err) return reject(err);\n\n        const list = response\n          .getPricesList()\n          .map((mktWithFee: types.PriceWithFee) => mktWithFee.toObject());\n\n        resolve(list);\n      });\n    });\n  }\n\n  balances({\n    baseAsset,\n    quoteAsset,\n  }: {\n    baseAsset: string;\n    quoteAsset: string;\n  }): Promise<Array<types.BalanceWithFee.AsObject>> {\n    const market = new types.Market();\n    market.setBaseAsset(baseAsset);\n    market.setQuoteAsset(quoteAsset);\n    const request = new messages.BalancesRequest();\n    request.setMarket(market);\n\n    return new Promise((resolve, reject) => {\n      this.client.balances(request, null, (err, response) => {\n        if (err) return reject(err);\n\n        const reply = response\n          .getBalancesList()\n          .map((balanceWithFee: types.BalanceWithFee) =>\n            balanceWithFee.toObject()\n          );\n\n        resolve(reply);\n      });\n    });\n  }\n}\n\nexport function throwErrorIfSwapFail(\n  tradeReply: messages.TradeProposeReply | messages.TradeCompleteReply\n) {\n  const swapFail = tradeReply.getSwapFail();\n  if (swapFail) {\n    const errorMessage = `SwapFail for message id=${swapFail.getId()}. Failure code ${swapFail.getFailureCode()} | reason: ${swapFail.getFailureMessage()}`;\n    throw new Error(errorMessage);\n  }\n}\n","import Core, { CoreInterface } from './core';\nimport { Swap } from './swap';\nimport {\n  UtxoInterface,\n  IdentityInterface,\n  CoinSelector,\n  isValidAmount,\n} from 'ldk';\nimport TraderClientInterface from './grpcClientInterface';\nimport { SwapAccept } from 'tdex-protobuf/generated/js/swap_pb';\nimport { SwapTransaction } from './transaction';\n\nexport interface MarketInterface {\n  baseAsset: string;\n  quoteAsset: string;\n}\n\nexport interface TradeInterface extends CoreInterface {\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n}\n\nexport enum TradeType {\n  BUY = 0,\n  SELL = 1,\n}\n\nexport interface TradeOpts {\n  providerUrl: string;\n  explorerUrl: string;\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n}\n\nexport interface BuySellOpts {\n  market: MarketInterface;\n  amount: number;\n  asset: string;\n  identity: IdentityInterface;\n}\n\ntype TraderClientInterfaceFactory = (\n  providerUrl: string\n) => TraderClientInterface;\n\nexport class TradeCore extends Core implements TradeInterface {\n  grpcClient: TraderClientInterface;\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n\n  constructor(\n    args: TradeOpts,\n    factoryTraderClient: TraderClientInterfaceFactory\n  ) {\n    super(args);\n\n    this.validate(args);\n    this.utxos = args.utxos;\n    this.coinSelector = args.coinSelector;\n    this.grpcClient = factoryTraderClient(args.providerUrl);\n  }\n\n  validate(args: TradeOpts) {\n    if (!this.providerUrl)\n      throw new Error(\n        'To be able to trade you need to select a liquidity provider via { providerUrl }'\n      );\n\n    if (!this.explorerUrl)\n      throw new Error(\n        'To be able to trade you need to select an explorer via { explorerUrl }'\n      );\n\n    if (args.utxos.length <= 0) {\n      throw new Error('You need at least one utxo to trade');\n    }\n  }\n\n  /**\n   * Trade.buy let the trader buy the baseAsset,\n   * sending his own quoteAsset using the current market price\n   */\n  async buy({ market, amount, asset, identity }: BuySellOpts): Promise<string> {\n    const swapAccept = await this.marketOrderRequest(\n      market,\n      TradeType.BUY,\n      amount,\n      asset,\n      identity\n    );\n    const txid = await this.marketOrderComplete(swapAccept, identity);\n    return txid;\n  }\n\n  /**\n   * Trade.sell let the trader sell the baseAsset,\n   * receiving the quoteAsset using the current market price\n   */\n  async sell({\n    market,\n    amount,\n    asset,\n    identity,\n  }: BuySellOpts): Promise<string> {\n    const swapAccept = await this.marketOrderRequest(\n      market,\n      TradeType.SELL,\n      amount,\n      asset,\n      identity\n    );\n    const txid = await this.marketOrderComplete(swapAccept, identity);\n    return txid;\n  }\n\n  async preview({\n    market,\n    tradeType,\n    amount,\n    asset,\n  }: {\n    market: MarketInterface;\n    tradeType: TradeType;\n    amount: number;\n    asset: string;\n  }): Promise<{\n    assetToBeSent: string;\n    amountToBeSent: number;\n    assetToReceive: string;\n    amountToReceive: number;\n  }> {\n    if (!isValidAmount(amount)) {\n      throw new Error('Amount is not valid');\n    }\n    const { baseAsset, quoteAsset } = market;\n\n    const prices = await this.grpcClient.marketPrice(\n      {\n        baseAsset,\n        quoteAsset,\n      },\n      tradeType,\n      amount,\n      asset\n    );\n\n    const previewedAmount = prices[0].amount;\n    if (tradeType === TradeType.BUY) {\n      return {\n        assetToBeSent: quoteAsset,\n        amountToBeSent: asset === baseAsset ? previewedAmount : amount,\n        assetToReceive: baseAsset,\n        amountToReceive: asset === baseAsset ? amount : previewedAmount,\n      };\n    }\n\n    return {\n      assetToBeSent: baseAsset,\n      amountToBeSent: asset === quoteAsset ? previewedAmount : amount,\n      assetToReceive: quoteAsset,\n      amountToReceive: asset === quoteAsset ? amount : previewedAmount,\n    };\n  }\n\n  private async marketOrderRequest(\n    market: MarketInterface,\n    tradeType: TradeType,\n    amountInSatoshis: number,\n    assetHash: string,\n    identity: IdentityInterface\n  ): Promise<Uint8Array> {\n    const {\n      assetToBeSent,\n      amountToBeSent,\n      assetToReceive,\n      amountToReceive,\n    } = await this.preview({\n      market,\n      tradeType,\n      amount: amountInSatoshis,\n      asset: assetHash,\n    });\n\n    const addressForOutput = identity.getNextAddress();\n    const addressForChange = identity.getNextChangeAddress();\n\n    const swapTx = new SwapTransaction(identity);\n    swapTx.create(\n      this.utxos,\n      amountToBeSent,\n      amountToReceive,\n      assetToBeSent,\n      assetToReceive,\n      addressForOutput.confidentialAddress,\n      addressForChange.confidentialAddress\n    );\n\n    const swap = new Swap();\n    const swapRequestSerialized = await swap.request({\n      assetToBeSent,\n      amountToBeSent,\n      assetToReceive,\n      amountToReceive,\n      psetBase64: swapTx.pset.toBase64(),\n      inputBlindingKeys: swapTx.inputBlindingKeys,\n      outputBlindingKeys: swapTx.outputBlindingKeys,\n    });\n\n    // 0 === Buy === receiving base_asset; 1 === sell === receiving base_asset\n    const swapAcceptSerialized: Uint8Array = await this.grpcClient.tradePropose(\n      market,\n      tradeType,\n      swapRequestSerialized\n    );\n\n    return swapAcceptSerialized;\n  }\n\n  private async marketOrderComplete(\n    swapAcceptSerialized: Uint8Array,\n    identity: IdentityInterface\n  ): Promise<string> {\n    // trader need to check the signed inputs by the provider\n    // and add his own inputs if all is correct\n    const swapAcceptMessage = SwapAccept.deserializeBinary(\n      swapAcceptSerialized\n    );\n    const transaction = swapAcceptMessage.getTransaction();\n    const signedPset = await identity.signPset(transaction);\n\n    // Trader  adds his signed inputs to the transaction\n    const swap = new Swap();\n    const swapCompleteSerialized = swap.complete({\n      message: swapAcceptSerialized,\n      psetBase64: signedPset,\n    });\n\n    // Trader call the tradeComplete endpoint to finalize the swap\n    const txid = await this.grpcClient.tradeComplete(swapCompleteSerialized);\n    return txid;\n  }\n}\n","import {\n  greedyCoinSelector,\n  UtxoInterface,\n  networks,\n  address,\n  RecipientInterface,\n  IdentityInterface,\n  CoinSelector,\n} from 'ldk';\nimport { confidential, Psbt } from 'liquidjs-lib';\n\n// SwapTransactionInterface defines the minimum needed for implementation to hold data to construct a valid swap transaction.\ninterface SwapTransactionInterface {\n  network: networks.Network;\n  pset: Psbt;\n  inputBlindingKeys: Record<string, Buffer>;\n  outputBlindingKeys: Record<string, Buffer>;\n}\n\n// SwapTransaction holds a pset and expose a create method to select coins and build a transaction for a SwapRequest message\nexport class SwapTransaction implements SwapTransactionInterface {\n  network: networks.Network;\n  pset: Psbt;\n  inputBlindingKeys: Record<string, Buffer> = {};\n  outputBlindingKeys: Record<string, Buffer> = {};\n\n  private identity: IdentityInterface;\n\n  constructor(identity: IdentityInterface) {\n    this.identity = identity;\n    this.network = identity.network;\n    this.pset = new Psbt({ network: this.network });\n  }\n\n  create(\n    unspents: Array<UtxoInterface>,\n    amountToBeSent: number,\n    amountToReceive: number,\n    assetToBeSent: string,\n    assetToReceive: string,\n    addressForSwapOutput: string,\n    addressForChangeOutput: string,\n    coinSelector: CoinSelector = greedyCoinSelector()\n  ) {\n    const { selectedUtxos, changeOutputs } = coinSelector(\n      unspents,\n      [\n        {\n          value: amountToBeSent,\n          asset: assetToBeSent,\n          address: '',\n        },\n      ],\n      (_: string) => addressForChangeOutput\n    );\n\n    selectedUtxos.forEach((i: UtxoInterface) => {\n      this.pset.addInput({\n        // if hash is string, txid, if hash is Buffer, is reversed compared to txid\n        hash: i.txid,\n        index: i.vout,\n        //We put here the blinded prevout\n        witnessUtxo: i.prevout,\n      });\n\n      if (!i.prevout) {\n        throw new Error(\n          'create tx: missing prevout member for input ' + i.txid + ':' + i.vout\n        );\n      }\n\n      // we update the inputBlindingKeys map after we add an input to the transaction\n      const scriptHex = i.prevout.script.toString('hex');\n      this.inputBlindingKeys[scriptHex] = Buffer.from(\n        this.identity.getBlindingPrivateKey(scriptHex),\n        'hex'\n      );\n    });\n\n    const receivingScript = address\n      .toOutputScript(addressForSwapOutput, this.network)\n      .toString('hex');\n\n    // The receiving output\n    this.pset.addOutput({\n      script: receivingScript,\n      value: confidential.satoshiToConfidentialValue(amountToReceive),\n      asset: assetToReceive,\n      nonce: Buffer.from('00', 'hex'),\n    });\n\n    // we update the outputBlindingKeys map after we add the receiving output to the transaction\n    this.outputBlindingKeys[receivingScript] = Buffer.from(\n      this.identity.getBlindingPrivateKey(receivingScript),\n      'hex'\n    );\n\n    if (changeOutputs.length > 0) {\n      changeOutputs.forEach((changeOutput: RecipientInterface) => {\n        const changeScript = address\n          .toOutputScript(changeOutput.address, this.network)\n          .toString('hex');\n\n        // Change\n        this.pset.addOutput({\n          script: changeScript,\n          value: confidential.satoshiToConfidentialValue(changeOutput.value),\n          asset: changeOutput.asset,\n          nonce: Buffer.from('00', 'hex'),\n        });\n\n        // we update the outputBlindingKeys map after we add the change output to the transaction\n        this.outputBlindingKeys[changeScript] = Buffer.from(\n          this.identity.getBlindingPrivateKey(changeScript),\n          'hex'\n        );\n      });\n    }\n  }\n}\n","import { TraderClient } from './grpcClient.web';\nimport { TradeCore, TradeInterface, TradeOpts } from './trade-core';\n\nexport class Trade extends TradeCore implements TradeInterface {\n  constructor(args: TradeOpts) {\n    super(args, (provider: string) => new TraderClient(provider));\n  }\n}\n"],"names":["Symbol","iterator","asyncIterator","Core","data","Object","assign","this","makeid","length","result","characters","charactersLength","i","charAt","Math","floor","random","decodePsbt","psetBase64","psbt","Psbt","fromBase64","ignore","Error","bufferTx","globalMap","unsignedTx","toBuffer","transaction","Transaction","fromBuffer","countUtxos","utxos","asset","inputBlindKeys","assetBuffer","Buffer","from","reverse","filteredByWitness","filter","witnessUtxo","Promise","all","map","isConfidentialOutput","blindKey","script","toString","undefined","unblindOutput","blindedAsset","blindedValue","value","surjectionProof","rangeProof","nonce","unblindValue","unblindAsset","unblindedUtxos","equals","slice","confidential","confidentialValueToSatoshi","reduce","a","b","outputFoundInTransaction","outputs","outputBlindKeys","some","o","isAsset","isValue","isConfidential","body","recover","e","then","compareMessagesAndTransaction","msgRequest","msgAccept","decodedFromRequest","getTransaction","inputs","forEach","inputIndex","nonWitnessUtxo","vout","ins","index","fromHex","outs","getAssetP","blindKeysMap","getInputBlindingKeyMap","totalP","getAmountP","getAmountR","getAssetR","getOutputBlindingKeyMap","outputRFound","decodedFromAccept","getId","getRequestId","totalR","Swap","request","amountToBeSent","assetToBeSent","amountToReceive","assetToReceive","inputBlindingKeys","outputBlindingKeys","msg","proto","setId","setAmountP","setAssetP","setAmountR","setAssetR","setTransaction","entries","key","set","Uint8Array","_this2","verbose","console","log","toObject","serializeBinary","accept","message","deserializeBinary","setRequestId","_this4","complete","validateSignaturesOfAllInputs","msgComplete","setAcceptId","jspbMap","entry","type","JSON","stringify","TraderClient","providerUrl","url","URL","hostname","includes","protocol","torProxyEndpoint","process","env","TOR_PROXY_ENDPOINT","splitted","split","pop","join","getClearTextTorProxyUrl","client","services","tradePropose","tradeType","swapRequestSerialized","baseAsset","quoteAsset","resolve","reject","market","types","setBaseAsset","setQuoteAsset","messages","setMarket","setType","setSwapRequest","SwapRequest","call","_this","on","reply","throwErrorIfSwapFail","swapAcceptMsg","getSwapAccept","tradeComplete","swapCompleteSerialized","setSwapComplete","SwapComplete","getTxid","markets","_this3","err","response","list","getMarketsList","mktWithFee","getMarket","getBaseAsset","getQuoteAsset","feeBasisPoint","getFee","getBasisPoint","marketPrice","amount","setAmount","setAsset","getPricesList","balances","_this5","getBalancesList","balanceWithFee","tradeReply","swapFail","getSwapFail","errorMessage","getFailureCode","getFailureMessage","TradeType","SwapTransaction","identity","network","pset","create","unspents","addressForSwapOutput","addressForChangeOutput","coinSelector","greedyCoinSelector","address","_","changeOutputs","selectedUtxos","addInput","hash","txid","prevout","scriptHex","getBlindingPrivateKey","receivingScript","toOutputScript","addOutput","satoshiToConfidentialValue","changeOutput","changeScript","TradeCore","args","factoryTraderClient","validate","grpcClient","explorerUrl","buy","marketOrderRequest","BUY","swapAccept","marketOrderComplete","sell","SELL","preview","isValidAmount","prices","previewedAmount","amountInSatoshis","assetHash","_this9","addressForOutput","getNextAddress","addressForChange","getNextChangeAddress","swapTx","confidentialAddress","swap","toBase64","swapAcceptSerialized","SwapAccept","signPset","signedPset","_this11","Trade","_TradeCore","provider"],"mappings":"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"}