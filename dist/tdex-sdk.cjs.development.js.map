{"version":3,"file":"tdex-sdk.cjs.development.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/core.ts","../src/utils.ts","../src/swap.ts","../src/transaction.ts","../src/trade-core.ts","../src/grpcClient.ts","../src/trade.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export interface CoreInterface {\n  verbose?: Boolean;\n  chain?: string;\n  providerUrl?: string;\n  explorerUrl?: string;\n}\n\nexport default class Core {\n  public verbose?: Boolean = false;\n  public chain?: string = 'regtest';\n  public providerUrl?: string;\n  public explorerUrl?: string;\n\n  constructor(data?: SafePick<Core>) {\n    Object.assign(this, data);\n  }\n}\n\ntype NonMethodKeys<T> = ({\n  [P in keyof T]: T[P] extends Function ? never : P;\n} & { [x: string]: never })[keyof T];\ntype SafePick<T> = Pick<T, NonMethodKeys<T>>;\n","import { Psbt, Transaction } from 'liquidjs-lib';\n\n/**\n * Generates a random id of a fixed length.\n * @param length size of the string id.\n */\nexport function makeid(length: number): string {\n  let result = '';\n  const characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport function decodePsbt(\n  psetBase64: string\n): { psbt: Psbt; transaction: Transaction } {\n  let psbt: Psbt;\n  try {\n    psbt = Psbt.fromBase64(psetBase64);\n  } catch (ignore) {\n    throw new Error('Invalid psbt');\n  }\n\n  const bufferTx = psbt.data.globalMap.unsignedTx.toBuffer();\n  const transaction = Transaction.fromBuffer(bufferTx);\n  return {\n    psbt,\n    transaction,\n  };\n}\n\nexport function getClearTextTorProxyUrl(\n  torProxyEndpoint: string,\n  url: URL\n): string {\n  // get just_onion_host_without_dot_onion\n  const splitted = url.hostname.split('.');\n  splitted.pop();\n  const onionPubKey = splitted.join('.');\n\n  return `${torProxyEndpoint}/${onionPubKey}`;\n}\n","import Core from './core';\nimport { confidential, TxOutput, Transaction } from 'liquidjs-lib';\nimport * as proto from 'tdex-protobuf/generated/js/swap_pb';\nimport * as jspb from 'google-protobuf';\nimport { isConfidentialOutput, unblindOutput } from 'ldk';\nimport { makeid, decodePsbt } from './utils';\n\n// type for BlindingKeys\ntype BlindKeysMap = Record<string, Buffer>;\n\n// define the Swap.request arguments.\ninterface requestOpts {\n  assetToBeSent: string;\n  amountToBeSent: number;\n  assetToReceive: string;\n  amountToReceive: number;\n  psetBase64: string;\n  inputBlindingKeys?: BlindKeysMap;\n  outputBlindingKeys?: BlindKeysMap;\n}\n\n// define the Swap.accept arguments.\ninterface acceptOpts {\n  message: Uint8Array;\n  psetBase64: string;\n  inputBlindingKeys?: BlindKeysMap;\n  outputBlindingKeys?: BlindKeysMap;\n}\n\n/**\n * The Swap class implements the Swap TDEX protocol i.e swap.request, swap.accept and swap.complete.\n * @see https://github.com/TDex-network/tdex-specs/blob/master/03-swap-protocol.md\n */\nexport class Swap extends Core {\n  static parse = parse;\n\n  /**\n   * Create and serialize a SwapRequest Message.\n   * @param args the args of swap.request see requestOpts.\n   */\n  async request({\n    amountToBeSent,\n    assetToBeSent,\n    amountToReceive,\n    assetToReceive,\n    psetBase64,\n    inputBlindingKeys,\n    outputBlindingKeys,\n  }: requestOpts): Promise<Uint8Array> {\n    // Check amounts\n    const msg = new proto.SwapRequest();\n    msg.setId(makeid(8));\n    msg.setAmountP(amountToBeSent);\n    msg.setAssetP(assetToBeSent);\n    msg.setAmountR(amountToReceive);\n    msg.setAssetR(assetToReceive);\n    msg.setTransaction(psetBase64);\n\n    if (inputBlindingKeys) {\n      // set the input blinding keys\n      Object.entries(inputBlindingKeys).forEach(([key, value]) => {\n        msg.getInputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    if (outputBlindingKeys) {\n      // set the output blinding keys\n      Object.entries(outputBlindingKeys).forEach(([key, value]) => {\n        msg.getOutputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    // check the message content and transaction.\n    await compareMessagesAndTransaction(msg);\n\n    if (this.verbose) console.log(msg.toObject());\n\n    return msg.serializeBinary();\n  }\n\n  /**\n   * Create and serialize an accept message.\n   * @param args the Swap.accept args, see AcceptOpts.\n   */\n  async accept({\n    message,\n    psetBase64,\n    inputBlindingKeys,\n    outputBlindingKeys,\n  }: acceptOpts): Promise<Uint8Array> {\n    // deserialize message parameter to get the SwapRequest message.\n    const msgRequest = proto.SwapRequest.deserializeBinary(message);\n    // Build Swap Accept message\n    const msgAccept = new proto.SwapAccept();\n    msgAccept.setId(makeid(8));\n    msgAccept.setRequestId(msgRequest.getId());\n    msgAccept.setTransaction(psetBase64);\n\n    if (inputBlindingKeys) {\n      // set the input blinding keys\n      Object.entries(inputBlindingKeys).forEach(([key, value]) => {\n        msgAccept.getInputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    if (outputBlindingKeys) {\n      // set the output blinding keys\n      Object.entries(outputBlindingKeys).forEach(([key, value]) => {\n        msgAccept.getOutputBlindingKeyMap().set(key, Uint8Array.from(value));\n      });\n    }\n\n    // compare messages and transaction data\n    await compareMessagesAndTransaction(msgRequest, msgAccept);\n\n    if (this.verbose) console.log(msgAccept.toObject());\n\n    // serialize the SwapAccept message.\n    return msgAccept.serializeBinary();\n  }\n\n  /**\n   * create and serialize a SwapComplete message.\n   * @param args contains the SwapAccept message + the base64 encoded transaction.\n   */\n  complete({\n    message,\n    psetBase64,\n  }: {\n    message: Uint8Array;\n    psetBase64: string;\n  }): Uint8Array {\n    //First validate signatures\n    const { psbt } = decodePsbt(psetBase64);\n\n    if (!psbt.validateSignaturesOfAllInputs())\n      throw new Error('Signatures not valid');\n\n    const msgAccept = proto.SwapAccept.deserializeBinary(message);\n    //Build SwapComplete\n    const msgComplete = new proto.SwapComplete();\n    msgComplete.setId(makeid(8));\n    msgComplete.setAcceptId(msgAccept.getId());\n    msgComplete.setTransaction(psetBase64);\n\n    if (this.verbose) console.log(msgAccept.toObject());\n\n    return msgComplete.serializeBinary();\n  }\n}\n\n/**\n * Take a swap messages and check if the message's data is corresponding to the  msg's transaction.\n * @param msgRequest the swap request message.\n * @param msgAccept the swap accept message.\n */\nasync function compareMessagesAndTransaction(\n  msgRequest: proto.SwapRequest,\n  msgAccept?: proto.SwapAccept\n): Promise<void> {\n  // decode the transaction.\n  const decodedFromRequest = decodePsbt(msgRequest.getTransaction());\n\n  // nonWitnessUtxo to witnessUtxoutxos\n  decodedFromRequest.psbt.data.inputs.forEach((i: any, inputIndex: number) => {\n    if (!i.witnessUtxo && i.nonWitnessUtxo) {\n      const vout: number = decodedFromRequest.transaction.ins[inputIndex].index;\n      const witnessUtxo: TxOutput = Transaction.fromHex(i.nonWitnessUtxo).outs[\n        vout\n      ];\n      i.witnessUtxo = witnessUtxo;\n    }\n  });\n\n  // check the amount of the transaction\n  const totalP = await countUtxos(\n    decodedFromRequest.psbt.data.inputs,\n    msgRequest.getAssetP(),\n    blindKeysMap(msgRequest.getInputBlindingKeyMap())\n  );\n\n  if (totalP < msgRequest.getAmountP()) {\n    throw new Error(\n      'Cumulative utxos count is not enough to cover SwapRequest.amount_p'\n    );\n  }\n\n  // check if the output if found in the transaction\n  const outputRFound: boolean = await outputFoundInTransaction(\n    decodedFromRequest.transaction.outs,\n    msgRequest.getAmountR(),\n    msgRequest.getAssetR(),\n    blindKeysMap(msgRequest.getOutputBlindingKeyMap())\n  );\n\n  if (!outputRFound)\n    throw new Error(\n      `Either SwapRequest.amount_r or SwapRequest.asset_r do not match the provided psbt (amount: ${msgRequest.getAmountR()}, asset: ${msgRequest.getAssetR()})`\n    );\n\n  // msg accept\n  if (msgAccept) {\n    // decode the tx and check the msg's ids\n    const decodedFromAccept = decodePsbt(msgAccept.getTransaction());\n    if (msgRequest.getId() !== msgAccept.getRequestId())\n      throw new Error(\n        'SwapRequest.id and SwapAccept.request_id are not the same'\n      );\n\n    // check the amount of utxos.\n    const totalR = await countUtxos(\n      decodedFromAccept.psbt.data.inputs,\n      msgRequest.getAssetR(),\n      blindKeysMap(msgAccept.getInputBlindingKeyMap())\n    );\n\n    if (totalR < msgRequest.getAmountR()) {\n      throw new Error(\n        'Cumulative utxos count is not enough to cover SwapRequest.amount_r'\n      );\n    }\n\n    // check if there is an output found in the transaction.\n    const outputPFound = outputFoundInTransaction(\n      decodedFromAccept.transaction.outs,\n      msgRequest.getAmountP(),\n      msgRequest.getAssetP(),\n      blindKeysMap(msgAccept.getOutputBlindingKeyMap())\n    );\n\n    if (!outputPFound)\n      throw new Error(\n        `Either SwapRequest.amount_p or SwapRequest.asset_p do not match the provided psbt amount=${msgRequest.getAmountP()} asset=${msgRequest.getAssetP()}`\n      );\n  }\n}\n\n/**\n * find an output in outputs corresponding to value and asset. Provide outputBlindKeys if output are blinded.\n * @param outputs the outputs to search in.\n * @param value value of the output.\n * @param asset hex encoded asset of the output.\n * @param outputBlindKeys optional, only if blinded outputs. Blinding keys map (scriptPukKey -> blindingKey).\n */\nasync function outputFoundInTransaction(\n  outputs: Array<TxOutput>,\n  value: number,\n  asset: string,\n  outputBlindKeys: BlindKeysMap = {}\n): Promise<boolean> {\n  return outputs.some(async (o: TxOutput) => {\n    // unblind first if confidential ouput\n    const isConfidential = isConfidentialOutput(o);\n    if (isConfidential === true) {\n      const blindKey: Buffer = outputBlindKeys[o.script.toString('hex')];\n      // if no blinding keys for the confidential ouput --> return false\n      if (blindKey === undefined)\n        throw new Error(`no blind key for ${o.script.toString('hex')}`);\n      try {\n        const {\n          value: unblindValue,\n          asset: unblindAsset,\n        } = await unblindOutput(\n          {\n            blindedAsset: o.asset,\n            blindedValue: o.value,\n            script: o.script.toString('hex'),\n            surjectionProof: o.surjectionProof!,\n            rangeProof: o.rangeProof!,\n            nonce: o.nonce,\n          },\n          blindKey.toString('hex')\n        );\n        // check unblind value and unblind asset\n        return unblindValue === value && unblindAsset === asset;\n      } catch (_) {\n        // if unblind fail --> return false\n        return false;\n      }\n    }\n    // check value and asset\n    const assetBuffer: Buffer = Buffer.from(asset, 'hex').reverse();\n    const isAsset: boolean = assetBuffer.equals(o.asset.slice(1));\n    const isValue: boolean =\n      confidential.confidentialValueToSatoshi(o.value) === value;\n    return isAsset && isValue;\n  });\n}\n\n/**\n * Returns the sum of the values of the given inputs' utxos.\n * @param utxos the inputs.\n * @param asset the asset to fetch value.\n * @param inputBlindKeys optional, the blinding keys using to unblind witnessUtxo if blinded.\n */\nasync function countUtxos(\n  utxos: Array<any>,\n  asset: string,\n  inputBlindKeys: BlindKeysMap = {}\n): Promise<number> {\n  const assetBuffer: Buffer = Buffer.from(asset, 'hex').reverse();\n  const filteredByWitness = utxos.filter((i: any) => i.witnessUtxo != null);\n\n  // unblind confidential prevouts\n  const unblindedUtxos: any[] = await Promise.all(\n    filteredByWitness.map(async (i: any) => {\n      if (i.witnessUtxo && isConfidentialOutput(i.witnessUtxo)) {\n        const blindKey = inputBlindKeys[i.witnessUtxo.script.toString('hex')];\n        if (blindKey === undefined) {\n          throw new Error(\n            'no blindKey for script: ' + i.witnessUtxo.script.toString('hex')\n          );\n        }\n        const {\n          value: unblindValue,\n          asset: unblindAsset,\n        } = await unblindOutput(\n          {\n            blindedAsset: i.witnessUtxo.asset,\n            blindedValue: i.witnessUtxo.value,\n            script: i.witnessUtxo.script.toString('hex'),\n            surjectionProof: i.witnessUtxo.surjectionProof!,\n            rangeProof: i.witnessUtxo.rangeProof!,\n            nonce: i.witnessUtxo.nonce,\n          },\n          blindKey.toString('hex')\n        );\n        i.value = unblindValue;\n        i.asset = unblindAsset;\n        i.witnessUtxo.value = unblindValue;\n      }\n      return i;\n    })\n  );\n\n  // filter inputs by asset and return the the count\n  const filteredByAsset = unblindedUtxos.filter((i: any) => {\n    return (\n      assetBuffer.equals(i.witnessUtxo.asset.slice(1)) || i.asset === asset\n    );\n  });\n\n  const queryValues = filteredByAsset.map((i: any) => {\n    const valAsNumber: number =\n      i.witnessUtxo.value instanceof Buffer\n        ? confidential.confidentialValueToSatoshi(i.witnessUtxo!.value)\n        : i.witnessUtxo!.value;\n    return valAsNumber;\n  });\n\n  // apply reducer to values (add the values)\n  return queryValues.reduce((a: any, b: any) => a + b, 0);\n}\n\nfunction parse({\n  message,\n  type,\n}: {\n  message: Uint8Array;\n  type: string;\n}): string {\n  let msg: any;\n  try {\n    msg = (proto as any)[type].deserializeBinary(message);\n  } catch (e) {\n    throw new Error(`Not valid message of expected type ${type}`);\n  }\n\n  return JSON.stringify(msg.toObject(), undefined, 2);\n}\n\n/**\n * Convert jspb's Map type to BlindKeysMap.\n * @param jspbMap the map to convert.\n */\nexport function blindKeysMap(\n  jspbMap: jspb.Map<string, string | Uint8Array>\n): BlindKeysMap | undefined {\n  const map: BlindKeysMap = {};\n  jspbMap.forEach((entry: string | Uint8Array, key: string) => {\n    const value: Buffer =\n      entry instanceof Uint8Array\n        ? Buffer.from(entry)\n        : Buffer.from(entry, 'hex');\n\n    map[key] = value;\n  });\n  return map;\n}\n","import {\n  greedyCoinSelector,\n  UtxoInterface,\n  networks,\n  address,\n  RecipientInterface,\n  IdentityInterface,\n  CoinSelector,\n} from 'ldk';\nimport { confidential, Psbt } from 'liquidjs-lib';\n\n// SwapTransactionInterface defines the minimum needed for implementation to hold data to construct a valid swap transaction.\ninterface SwapTransactionInterface {\n  network: networks.Network;\n  pset: Psbt;\n  inputBlindingKeys: Record<string, Buffer>;\n  outputBlindingKeys: Record<string, Buffer>;\n}\n\n// SwapTransaction holds a pset and expose a create method to select coins and build a transaction for a SwapRequest message\nexport class SwapTransaction implements SwapTransactionInterface {\n  network: networks.Network;\n  pset: Psbt;\n  inputBlindingKeys: Record<string, Buffer> = {};\n  outputBlindingKeys: Record<string, Buffer> = {};\n\n  private identity: IdentityInterface;\n\n  constructor(identity: IdentityInterface) {\n    this.identity = identity;\n    this.network = identity.network;\n    this.pset = new Psbt({ network: this.network });\n  }\n\n  create(\n    unspents: Array<UtxoInterface>,\n    amountToBeSent: number,\n    amountToReceive: number,\n    assetToBeSent: string,\n    assetToReceive: string,\n    addressForSwapOutput: string,\n    addressForChangeOutput: string,\n    coinSelector: CoinSelector = greedyCoinSelector()\n  ) {\n    const { selectedUtxos, changeOutputs } = coinSelector(\n      unspents,\n      [\n        {\n          value: amountToBeSent,\n          asset: assetToBeSent,\n          address: '',\n        },\n      ],\n      (_: string) => addressForChangeOutput\n    );\n\n    selectedUtxos.forEach((i: UtxoInterface) => {\n      this.pset.addInput({\n        // if hash is string, txid, if hash is Buffer, is reversed compared to txid\n        hash: i.txid,\n        index: i.vout,\n        //We put here the blinded prevout\n        witnessUtxo: i.prevout,\n      });\n\n      if (!i.prevout) {\n        throw new Error(\n          'create tx: missing prevout member for input ' + i.txid + ':' + i.vout\n        );\n      }\n\n      // we update the inputBlindingKeys map after we add an input to the transaction\n      const scriptHex = i.prevout.script.toString('hex');\n      this.inputBlindingKeys[scriptHex] = Buffer.from(\n        this.identity.getBlindingPrivateKey(scriptHex),\n        'hex'\n      );\n    });\n\n    const receivingScript = address\n      .toOutputScript(addressForSwapOutput, this.network)\n      .toString('hex');\n\n    // The receiving output\n    this.pset.addOutput({\n      script: receivingScript,\n      value: confidential.satoshiToConfidentialValue(amountToReceive),\n      asset: assetToReceive,\n      nonce: Buffer.from('00', 'hex'),\n    });\n\n    // we update the outputBlindingKeys map after we add the receiving output to the transaction\n    this.outputBlindingKeys[receivingScript] = Buffer.from(\n      this.identity.getBlindingPrivateKey(receivingScript),\n      'hex'\n    );\n\n    if (changeOutputs.length > 0) {\n      changeOutputs.forEach((changeOutput: RecipientInterface) => {\n        const changeScript = address\n          .toOutputScript(changeOutput.address, this.network)\n          .toString('hex');\n\n        // Change\n        this.pset.addOutput({\n          script: changeScript,\n          value: confidential.satoshiToConfidentialValue(changeOutput.value),\n          asset: changeOutput.asset,\n          nonce: Buffer.from('00', 'hex'),\n        });\n\n        // we update the outputBlindingKeys map after we add the change output to the transaction\n        this.outputBlindingKeys[changeScript] = Buffer.from(\n          this.identity.getBlindingPrivateKey(changeScript),\n          'hex'\n        );\n      });\n    }\n  }\n}\n","import Core, { CoreInterface } from './core';\nimport { Swap } from './swap';\nimport {\n  UtxoInterface,\n  IdentityInterface,\n  CoinSelector,\n  isValidAmount,\n} from 'ldk';\nimport TraderClientInterface from './grpcClientInterface';\nimport { SwapAccept } from 'tdex-protobuf/generated/js/swap_pb';\nimport { SwapTransaction } from './transaction';\n\nexport interface MarketInterface {\n  baseAsset: string;\n  quoteAsset: string;\n}\n\nexport interface TradeInterface extends CoreInterface {\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n}\n\nexport enum TradeType {\n  BUY = 0,\n  SELL = 1,\n}\n\nexport interface TradeOpts {\n  providerUrl: string;\n  explorerUrl: string;\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n}\n\nexport interface BuySellOpts {\n  market: MarketInterface;\n  amount: number;\n  asset: string;\n  identity: IdentityInterface;\n}\n\ntype TraderClientInterfaceFactory = (\n  providerUrl: string\n) => TraderClientInterface;\n\nexport class TradeCore extends Core implements TradeInterface {\n  grpcClient: TraderClientInterface;\n  utxos: Array<UtxoInterface>;\n  coinSelector: CoinSelector;\n\n  constructor(\n    args: TradeOpts,\n    factoryTraderClient: TraderClientInterfaceFactory\n  ) {\n    super(args);\n\n    this.validate(args);\n    this.utxos = args.utxos;\n    this.coinSelector = args.coinSelector;\n    this.grpcClient = factoryTraderClient(args.providerUrl);\n  }\n\n  validate(args: TradeOpts) {\n    if (!this.providerUrl)\n      throw new Error(\n        'To be able to trade you need to select a liquidity provider via { providerUrl }'\n      );\n\n    if (!this.explorerUrl)\n      throw new Error(\n        'To be able to trade you need to select an explorer via { explorerUrl }'\n      );\n\n    if (args.utxos.length <= 0) {\n      throw new Error('You need at least one utxo to trade');\n    }\n  }\n\n  /**\n   * Trade.buy let the trader buy the baseAsset,\n   * sending his own quoteAsset using the current market price\n   */\n  async buy({ market, amount, asset, identity }: BuySellOpts): Promise<string> {\n    const swapAccept = await this.marketOrderRequest(\n      market,\n      TradeType.BUY,\n      amount,\n      asset,\n      identity\n    );\n    const txid = await this.marketOrderComplete(swapAccept, identity);\n    return txid;\n  }\n\n  /**\n   * Trade.sell let the trader sell the baseAsset,\n   * receiving the quoteAsset using the current market price\n   */\n  async sell({\n    market,\n    amount,\n    asset,\n    identity,\n  }: BuySellOpts): Promise<string> {\n    const swapAccept = await this.marketOrderRequest(\n      market,\n      TradeType.SELL,\n      amount,\n      asset,\n      identity\n    );\n    const txid = await this.marketOrderComplete(swapAccept, identity);\n    return txid;\n  }\n\n  async preview({\n    market,\n    tradeType,\n    amount,\n    asset,\n  }: {\n    market: MarketInterface;\n    tradeType: TradeType;\n    amount: number;\n    asset: string;\n  }): Promise<{\n    assetToBeSent: string;\n    amountToBeSent: number;\n    assetToReceive: string;\n    amountToReceive: number;\n  }> {\n    if (!isValidAmount(amount)) {\n      throw new Error('Amount is not valid');\n    }\n    const { baseAsset, quoteAsset } = market;\n\n    const prices = await this.grpcClient.marketPrice(\n      {\n        baseAsset,\n        quoteAsset,\n      },\n      tradeType,\n      amount,\n      asset\n    );\n\n    const previewedAmount = prices[0].amount;\n    if (tradeType === TradeType.BUY) {\n      return {\n        assetToBeSent: quoteAsset,\n        amountToBeSent: asset === baseAsset ? previewedAmount : amount,\n        assetToReceive: baseAsset,\n        amountToReceive: asset === baseAsset ? amount : previewedAmount,\n      };\n    }\n\n    return {\n      assetToBeSent: baseAsset,\n      amountToBeSent: asset === quoteAsset ? previewedAmount : amount,\n      assetToReceive: quoteAsset,\n      amountToReceive: asset === quoteAsset ? amount : previewedAmount,\n    };\n  }\n\n  private async marketOrderRequest(\n    market: MarketInterface,\n    tradeType: TradeType,\n    amountInSatoshis: number,\n    assetHash: string,\n    identity: IdentityInterface\n  ): Promise<Uint8Array> {\n    const {\n      assetToBeSent,\n      amountToBeSent,\n      assetToReceive,\n      amountToReceive,\n    } = await this.preview({\n      market,\n      tradeType,\n      amount: amountInSatoshis,\n      asset: assetHash,\n    });\n\n    const addressForOutput = identity.getNextAddress();\n    const addressForChange = identity.getNextChangeAddress();\n\n    const swapTx = new SwapTransaction(identity);\n    swapTx.create(\n      this.utxos,\n      amountToBeSent,\n      amountToReceive,\n      assetToBeSent,\n      assetToReceive,\n      addressForOutput.confidentialAddress,\n      addressForChange.confidentialAddress\n    );\n\n    const swap = new Swap();\n    const swapRequestSerialized = await swap.request({\n      assetToBeSent,\n      amountToBeSent,\n      assetToReceive,\n      amountToReceive,\n      psetBase64: swapTx.pset.toBase64(),\n      inputBlindingKeys: swapTx.inputBlindingKeys,\n      outputBlindingKeys: swapTx.outputBlindingKeys,\n    });\n\n    // 0 === Buy === receiving base_asset; 1 === sell === receiving base_asset\n    const swapAcceptSerialized: Uint8Array = await this.grpcClient.tradePropose(\n      market,\n      tradeType,\n      swapRequestSerialized\n    );\n\n    return swapAcceptSerialized;\n  }\n\n  private async marketOrderComplete(\n    swapAcceptSerialized: Uint8Array,\n    identity: IdentityInterface\n  ): Promise<string> {\n    // trader need to check the signed inputs by the provider\n    // and add his own inputs if all is correct\n    const swapAcceptMessage = SwapAccept.deserializeBinary(\n      swapAcceptSerialized\n    );\n    const transaction = swapAcceptMessage.getTransaction();\n    const signedPset = await identity.signPset(transaction);\n\n    // Trader  adds his signed inputs to the transaction\n    const swap = new Swap();\n    const swapCompleteSerialized = swap.complete({\n      message: swapAcceptSerialized,\n      psetBase64: signedPset,\n    });\n\n    // Trader call the tradeComplete endpoint to finalize the swap\n    const txid = await this.grpcClient.tradeComplete(swapCompleteSerialized);\n    return txid;\n  }\n}\n","import * as grpc from '@grpc/grpc-js';\nimport * as services from 'tdex-protobuf/generated/js/trade_grpc_pb';\nimport * as messages from 'tdex-protobuf/generated/js/trade_pb';\nimport * as types from 'tdex-protobuf/generated/js/types_pb';\nimport { SwapRequest, SwapComplete } from 'tdex-protobuf/generated/js/swap_pb';\n\nimport TraderClientInterface from './grpcClientInterface';\n\nexport class TraderClient implements TraderClientInterface {\n  providerUrl: string;\n  client: services.TradeClient;\n\n  constructor(providerUrlString: string) {\n    let creds = grpc.credentials.createInsecure();\n\n    this.providerUrl = providerUrlString;\n    const url = new URL(providerUrlString);\n    this.client = new services.TradeClient(this.providerUrl, creds);\n\n    if (url.protocol.includes('https')) {\n      creds = grpc.credentials.createSsl();\n      this.client = new services.TradeClient(url.host, creds);\n    }\n  }\n  /**\n   * tradePropose\n   * @param market\n   * @param tradeType\n   * @param swapRequestSerialized\n   */\n  tradePropose(\n    { baseAsset, quoteAsset }: types.Market.AsObject,\n    tradeType: number,\n    swapRequestSerialized: Uint8Array\n  ): Promise<Uint8Array> {\n    return new Promise((resolve, reject) => {\n      const market = new types.Market();\n      market.setBaseAsset(baseAsset);\n      market.setQuoteAsset(quoteAsset);\n\n      const request = new messages.TradeProposeRequest();\n      request.setMarket(market);\n      request.setType(tradeType);\n      request.setSwapRequest(\n        SwapRequest.deserializeBinary(swapRequestSerialized)\n      );\n\n      const call = this.client.tradePropose(request);\n      let data: Uint8Array;\n      call.on('data', (reply: messages.TradeProposeReply) => {\n        throwErrorIfSwapFail(reply);\n        const swapAcceptMsg = reply!.getSwapAccept();\n        data = swapAcceptMsg!.serializeBinary();\n      });\n\n      call.on('end', () => resolve(data));\n      call.on('error', (e: any) => reject(e));\n    });\n  }\n\n  /**\n   * tradeComplete\n   * @param swapCompleteSerialized\n   */\n  tradeComplete(swapCompleteSerialized: Uint8Array): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const request = new messages.TradeCompleteRequest();\n      request.setSwapComplete(\n        SwapComplete.deserializeBinary(swapCompleteSerialized)\n      );\n      const call = this.client.tradeComplete(request);\n      let data: string;\n      call.on('data', (reply: messages.TradeCompleteReply) => {\n        throwErrorIfSwapFail(reply);\n        data = reply!.getTxid();\n      });\n      call.on('end', () => resolve(data));\n      call.on('error', (e: any) => reject(e));\n    });\n  }\n\n  markets(): Promise<\n    Array<{ baseAsset: string; quoteAsset: string; feeBasisPoint: number }>\n  > {\n    return new Promise((resolve, reject) => {\n      this.client.markets(new messages.MarketsRequest(), (err, response) => {\n        if (err) return reject(err);\n        const list = response!\n          .getMarketsList()\n          .map((mktWithFee: types.MarketWithFee) => ({\n            baseAsset: mktWithFee!.getMarket()!.getBaseAsset(),\n            quoteAsset: mktWithFee!.getMarket()!.getQuoteAsset(),\n            feeBasisPoint: mktWithFee!.getFee()!.getBasisPoint(),\n          }));\n        resolve(list);\n      });\n    });\n  }\n\n  marketPrice(\n    {\n      baseAsset,\n      quoteAsset,\n    }: {\n      baseAsset: string;\n      quoteAsset: string;\n    },\n    tradeType: number,\n    amount: number,\n    asset: string\n  ): Promise<Array<types.PriceWithFee.AsObject>> {\n    const market = new types.Market();\n    market.setBaseAsset(baseAsset);\n    market.setQuoteAsset(quoteAsset);\n    const request = new messages.MarketPriceRequest();\n    request.setMarket(market);\n    request.setType(tradeType);\n    request.setAmount(amount);\n    request.setAsset(asset);\n\n    return new Promise((resolve, reject) => {\n      this.client.marketPrice(request, (err, response) => {\n        if (err) return reject(err);\n\n        const list = response\n          .getPricesList()\n          .map((priceWithFee: types.PriceWithFee) => priceWithFee.toObject());\n\n        resolve(list);\n      });\n    });\n  }\n\n  balances({\n    baseAsset,\n    quoteAsset,\n  }: {\n    baseAsset: string;\n    quoteAsset: string;\n  }): Promise<Array<types.BalanceWithFee.AsObject>> {\n    const market = new types.Market();\n    market.setBaseAsset(baseAsset);\n    market.setQuoteAsset(quoteAsset);\n    const request = new messages.BalancesRequest();\n    request.setMarket(market);\n\n    return new Promise((resolve, reject) => {\n      this.client.balances(request, (err, response) => {\n        if (err) return reject(err);\n\n        const reply = response\n          .getBalancesList()\n          .map((balanceWithFee: types.BalanceWithFee) =>\n            balanceWithFee.toObject()\n          );\n\n        resolve(reply);\n      });\n    });\n  }\n}\n\nexport function throwErrorIfSwapFail(\n  tradeReply: messages.TradeProposeReply | messages.TradeCompleteReply\n) {\n  const swapFail = tradeReply.getSwapFail();\n  if (swapFail) {\n    const errorMessage = `SwapFail for message id=${swapFail.getId()}. Failure code ${swapFail.getFailureCode()} | reason: ${swapFail.getFailureMessage()}`;\n    throw new Error(errorMessage);\n  }\n}\n","import { TradeCore, TradeInterface, TradeOpts } from './trade-core';\nimport { TraderClient } from './grpcClient';\n\nexport class Trade extends TradeCore implements TradeInterface {\n  constructor(args: TradeOpts) {\n    super(args, (provider: string) => new TraderClient(provider));\n  }\n}\n"],"names":["Core","data","Object","assign","makeid","length","result","characters","charactersLength","i","charAt","Math","floor","random","decodePsbt","psetBase64","psbt","Psbt","fromBase64","ignore","Error","bufferTx","globalMap","unsignedTx","toBuffer","transaction","Transaction","fromBuffer","countUtxos","utxos","asset","inputBlindKeys","assetBuffer","Buffer","from","reverse","filteredByWitness","filter","witnessUtxo","Promise","all","map","isConfidentialOutput","blindKey","script","toString","undefined","unblindOutput","blindedAsset","blindedValue","value","surjectionProof","rangeProof","nonce","unblindValue","unblindAsset","unblindedUtxos","filteredByAsset","equals","slice","queryValues","valAsNumber","confidential","confidentialValueToSatoshi","reduce","a","b","outputFoundInTransaction","outputs","outputBlindKeys","some","o","isAsset","isValue","isConfidential","compareMessagesAndTransaction","msgRequest","msgAccept","decodedFromRequest","getTransaction","inputs","forEach","inputIndex","nonWitnessUtxo","vout","ins","index","fromHex","outs","getAssetP","blindKeysMap","getInputBlindingKeyMap","totalP","getAmountP","getAmountR","getAssetR","getOutputBlindingKeyMap","outputRFound","decodedFromAccept","getId","getRequestId","totalR","outputPFound","Swap","request","amountToBeSent","assetToBeSent","amountToReceive","assetToReceive","inputBlindingKeys","outputBlindingKeys","msg","proto","setId","setAmountP","setAssetP","setAmountR","setAssetR","setTransaction","entries","key","set","Uint8Array","verbose","console","log","toObject","serializeBinary","accept","message","deserializeBinary","setRequestId","complete","validateSignaturesOfAllInputs","msgComplete","setAcceptId","parse","type","e","JSON","stringify","jspbMap","entry","SwapTransaction","identity","network","pset","create","unspents","addressForSwapOutput","addressForChangeOutput","coinSelector","greedyCoinSelector","address","_","selectedUtxos","changeOutputs","addInput","hash","txid","prevout","scriptHex","getBlindingPrivateKey","receivingScript","toOutputScript","addOutput","satoshiToConfidentialValue","changeOutput","changeScript","TradeType","TradeCore","args","factoryTraderClient","validate","grpcClient","providerUrl","explorerUrl","buy","market","amount","marketOrderRequest","BUY","swapAccept","marketOrderComplete","sell","SELL","preview","tradeType","isValidAmount","baseAsset","quoteAsset","marketPrice","prices","previewedAmount","amountInSatoshis","assetHash","addressForOutput","getNextAddress","addressForChange","getNextChangeAddress","swapTx","confidentialAddress","swap","toBase64","swapRequestSerialized","tradePropose","swapAcceptSerialized","swapAcceptMessage","SwapAccept","signPset","signedPset","swapCompleteSerialized","tradeComplete","TraderClient","providerUrlString","creds","grpc","createInsecure","url","URL","client","services","protocol","includes","createSsl","host","resolve","reject","types","setBaseAsset","setQuoteAsset","messages","setMarket","setType","setSwapRequest","SwapRequest","call","on","reply","throwErrorIfSwapFail","swapAcceptMsg","getSwapAccept","setSwapComplete","SwapComplete","getTxid","markets","err","response","list","getMarketsList","mktWithFee","getMarket","getBaseAsset","getQuoteAsset","feeBasisPoint","getFee","getBasisPoint","setAmount","setAsset","getPricesList","priceWithFee","balances","getBalancesList","balanceWithFee","tradeReply","swapFail","getSwapFail","errorMessage","getFailureCode","getFailureMessage","Trade","provider"],"mappings":"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"}